Args: ../../build/bin/llc -O0 multi_para.ll --march=bpf -o multi_para.s -debug

Features:
CPU:
TuneCPU:

[SafeStack] Function: add
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry
---- Branch Probability Info : add ----

Computing probabilities for entry
Skipping pass 'BPF DAG->DAG Pattern Instruction Selection' on function add

Changing optimization level for Function add
	Before: -O2 ; After: -O0
	FastISel is enabled



=== add
Enabling fast-isel
Found argument copy elision candidate:   %a.addr = alloca i64, align 8
Found argument copy elision candidate:   %b.addr = alloca i64, align 8
Found argument copy elision candidate:   %c.addr = alloca i64, align 8
Found argument copy elision candidate:   %d.addr = alloca i64, align 8
Found argument copy elision candidate:   %e.addr = alloca i64, align 8
Found argument copy elision candidate:   %f.addr = alloca i64, align 8
Found argument copy elision candidate:   %g.addr = alloca i64, align 8
Creating new node: t2: i64,ch = CopyFromReg t0, Register:i64 %0
Creating new node: t4: i64,ch = CopyFromReg t0, Register:i64 %1
Creating new node: t6: i64,ch = CopyFromReg t0, Register:i64 %2
Creating new node: t8: i64,ch = CopyFromReg t0, Register:i64 %3
Creating new node: t10: i64,ch = CopyFromReg t0, Register:i64 %4
error: <unknown>:0:0: in function add i64 (i64, i64, i64, i64, i64, i64, i64): defined with too many args

Creating constant: t11: i64 = Constant<0>
error: <unknown>:0:0: in function add i64 (i64, i64, i64, i64, i64, i64, i64): defined with too many args

Creating new node: t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>
Creating new node: t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>
Creating new node: t17: i64 = undef
Creating new node: t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Creating new node: t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64
Creating new node: t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64
Creating new node: t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64
Creating new node: t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64
Creating new node: t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64
Creating new node: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Creating new node: t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64
Creating new node: t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64
Creating new node: t33: i64 = add nsw t31, t32
Creating new node: t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64
Creating new node: t35: i64 = add nsw t33, t34
Creating new node: t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64
Creating new node: t37: i64 = add nsw t35, t36
Creating new node: t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64
Creating new node: t39: i64 = add nsw t37, t38
Creating new node: t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64
Creating new node: t41: i64 = add nsw t39, t40
Creating new node: t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64
Creating new node: t43: i64 = add nsw t41, t42
Creating new node: t44: ch = TokenFactor t13, t15, t30
Creating new node: t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
Creating new node: t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1
Initial selection DAG: %bb.0 'add:entry'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
                t2: i64,ch = CopyFromReg t0, Register:i64 %0
              t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
              t4: i64,ch = CopyFromReg t0, Register:i64 %1
            t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64
            t6: i64,ch = CopyFromReg t0, Register:i64 %2
          t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64
          t8: i64,ch = CopyFromReg t0, Register:i64 %3
        t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64
        t10: i64,ch = CopyFromReg t0, Register:i64 %4
      t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64
    t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64
  t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
      t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>
      t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>
    t44: ch = TokenFactor t13, t15, t30
                t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64
                t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64
              t33: i64 = add nsw t31, t32
              t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64
            t35: i64 = add nsw t33, t34
            t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64
          t37: i64 = add nsw t35, t36
          t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64
        t39: i64 = add nsw t37, t38
        t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64
      t41: i64 = add nsw t39, t40
      t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64
    t43: i64 = add nsw t41, t42
  t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
  t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1



Combining: t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1

Combining: t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43

Combining: t45: i64 = Register $r0

Combining: t44: ch = TokenFactor t13, t15, t30

Combining: t43: i64 = add nsw t41, t42

Combining: t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64

Combining: t41: i64 = add nsw t39, t40

Combining: t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64

Combining: t39: i64 = add nsw t37, t38

Combining: t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64

Combining: t37: i64 = add nsw t35, t36

Combining: t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64

Combining: t35: i64 = add nsw t33, t34

Combining: t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64

Combining: t33: i64 = add nsw t31, t32

Combining: t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64

Combining: t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64

Combining: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64

Combining: t29: i64 = FrameIndex<6>

Combining: t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64

Combining: t27: i64 = FrameIndex<5>

Combining: t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64

Combining: t25: i64 = FrameIndex<4>

Combining: t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64

Combining: t23: i64 = FrameIndex<3>

Combining: t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64

Combining: t21: i64 = FrameIndex<2>

Combining: t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64

Combining: t19: i64 = FrameIndex<1>

Combining: t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64

Combining: t17: i64 = undef

Combining: t16: i64 = FrameIndex<0>

Combining: t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>

Combining: t14: i64 = Register %6

Combining: t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>

Combining: t12: i64 = Register %5

Combining: t11: i64 = Constant<0>

Combining: t10: i64,ch = CopyFromReg t0, Register:i64 %4

Combining: t9: i64 = Register %4

Combining: t8: i64,ch = CopyFromReg t0, Register:i64 %3

Combining: t7: i64 = Register %3

Combining: t6: i64,ch = CopyFromReg t0, Register:i64 %2

Combining: t5: i64 = Register %2

Combining: t4: i64,ch = CopyFromReg t0, Register:i64 %1

Combining: t3: i64 = Register %1

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %0

Combining: t1: i64 = Register %0

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'add:entry'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
                t2: i64,ch = CopyFromReg t0, Register:i64 %0
              t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
              t4: i64,ch = CopyFromReg t0, Register:i64 %1
            t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64
            t6: i64,ch = CopyFromReg t0, Register:i64 %2
          t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64
          t8: i64,ch = CopyFromReg t0, Register:i64 %3
        t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64
        t10: i64,ch = CopyFromReg t0, Register:i64 %4
      t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64
    t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64
  t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
      t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>
      t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>
    t44: ch = TokenFactor t13, t15, t30
                t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64
                t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64
              t33: i64 = add nsw t31, t32
              t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64
            t35: i64 = add nsw t33, t34
            t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64
          t37: i64 = add nsw t35, t36
          t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64
        t39: i64 = add nsw t37, t38
        t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64
      t41: i64 = add nsw t39, t40
      t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64
    t43: i64 = add nsw t41, t42
  t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
  t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1


Legalizing node: t45: i64 = Register $r0
Ignoring node results
Legally typed node: t45: i64 = Register $r0

Legalizing node: t29: i64 = FrameIndex<6>
Analyzing result type: i64
Legal result type
Legally typed node: t29: i64 = FrameIndex<6>

Legalizing node: t27: i64 = FrameIndex<5>
Analyzing result type: i64
Legal result type
Legally typed node: t27: i64 = FrameIndex<5>

Legalizing node: t25: i64 = FrameIndex<4>
Analyzing result type: i64
Legal result type
Legally typed node: t25: i64 = FrameIndex<4>

Legalizing node: t23: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t23: i64 = FrameIndex<3>

Legalizing node: t21: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t21: i64 = FrameIndex<2>

Legalizing node: t19: i64 = FrameIndex<1>
Analyzing result type: i64
Legal result type
Legally typed node: t19: i64 = FrameIndex<1>

Legalizing node: t17: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t17: i64 = undef

Legalizing node: t16: i64 = FrameIndex<0>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = FrameIndex<0>

Legalizing node: t14: i64 = Register %6
Ignoring node results
Legally typed node: t14: i64 = Register %6

Legalizing node: t12: i64 = Register %5
Ignoring node results
Legally typed node: t12: i64 = Register %5

Legalizing node: t11: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t11: i64 = Constant<0>

Legalizing node: t9: i64 = Register %4
Ignoring node results
Legally typed node: t9: i64 = Register %4

Legalizing node: t7: i64 = Register %3
Ignoring node results
Legally typed node: t7: i64 = Register %3

Legalizing node: t5: i64 = Register %2
Ignoring node results
Legally typed node: t5: i64 = Register %2

Legalizing node: t3: i64 = Register %1
Ignoring node results
Legally typed node: t3: i64 = Register %1

Legalizing node: t1: i64 = Register %0
Ignoring node results
Legally typed node: t1: i64 = Register %0

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i64,ch = CopyFromReg t0, Register:i64 %0
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i64,ch = CopyFromReg t0, Register:i64 %0

Legalizing node: t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t2: i64,ch = CopyFromReg t0, Register:i64 %0
Legal operand
Analyzing operand: t16: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64

Legalizing node: t4: i64,ch = CopyFromReg t0, Register:i64 %1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: i64,ch = CopyFromReg t0, Register:i64 %1

Legalizing node: t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t4: i64,ch = CopyFromReg t0, Register:i64 %1
Legal operand
Analyzing operand: t19: i64 = FrameIndex<1>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64

Legalizing node: t6: i64,ch = CopyFromReg t0, Register:i64 %2
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t6: i64,ch = CopyFromReg t0, Register:i64 %2

Legalizing node: t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t6: i64,ch = CopyFromReg t0, Register:i64 %2
Legal operand
Analyzing operand: t21: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64

Legalizing node: t8: i64,ch = CopyFromReg t0, Register:i64 %3
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t8: i64,ch = CopyFromReg t0, Register:i64 %3

Legalizing node: t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t8: i64,ch = CopyFromReg t0, Register:i64 %3
Legal operand
Analyzing operand: t23: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64

Legalizing node: t10: i64,ch = CopyFromReg t0, Register:i64 %4
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t10: i64,ch = CopyFromReg t0, Register:i64 %4

Legalizing node: t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t10: i64,ch = CopyFromReg t0, Register:i64 %4
Legal operand
Analyzing operand: t25: i64 = FrameIndex<4>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64

Legalizing node: t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64
Legal operand
Analyzing operand: t11: i64 = Constant<0>
Legal operand
Analyzing operand: t27: i64 = FrameIndex<5>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64

Legalizing node: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64
Legal operand
Analyzing operand: t11: i64 = Constant<0>
Legal operand
Analyzing operand: t29: i64 = FrameIndex<6>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64

Legalizing node: t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Legal operand
Analyzing operand: t16: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64

Legalizing node: t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Legal operand
Analyzing operand: t19: i64 = FrameIndex<1>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64

Legalizing node: t33: i64 = add nsw t31, t32
Analyzing result type: i64
Legal result type
Analyzing operand: t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64
Legal operand
Legally typed node: t33: i64 = add nsw t31, t32

Legalizing node: t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Legal operand
Analyzing operand: t21: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64

Legalizing node: t35: i64 = add nsw t33, t34
Analyzing result type: i64
Legal result type
Analyzing operand: t33: i64 = add nsw t31, t32
Legal operand
Analyzing operand: t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64
Legal operand
Legally typed node: t35: i64 = add nsw t33, t34

Legalizing node: t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Legal operand
Analyzing operand: t23: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64

Legalizing node: t37: i64 = add nsw t35, t36
Analyzing result type: i64
Legal result type
Analyzing operand: t35: i64 = add nsw t33, t34
Legal operand
Analyzing operand: t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64
Legal operand
Legally typed node: t37: i64 = add nsw t35, t36

Legalizing node: t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Legal operand
Analyzing operand: t25: i64 = FrameIndex<4>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64

Legalizing node: t39: i64 = add nsw t37, t38
Analyzing result type: i64
Legal result type
Analyzing operand: t37: i64 = add nsw t35, t36
Legal operand
Analyzing operand: t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64
Legal operand
Legally typed node: t39: i64 = add nsw t37, t38

Legalizing node: t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Legal operand
Analyzing operand: t27: i64 = FrameIndex<5>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64

Legalizing node: t41: i64 = add nsw t39, t40
Analyzing result type: i64
Legal result type
Analyzing operand: t39: i64 = add nsw t37, t38
Legal operand
Analyzing operand: t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64
Legal operand
Legally typed node: t41: i64 = add nsw t39, t40

Legalizing node: t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Legal operand
Analyzing operand: t29: i64 = FrameIndex<6>
Legal operand
Analyzing operand: t17: i64 = undef
Legal operand
Legally typed node: t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64

Legalizing node: t43: i64 = add nsw t41, t42
Analyzing result type: i64
Legal result type
Analyzing operand: t41: i64 = add nsw t39, t40
Legal operand
Analyzing operand: t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64
Legal operand
Legally typed node: t43: i64 = add nsw t41, t42

Legalizing node: t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t11: i64 = Constant<0>
Legal operand
Legally typed node: t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>

Legalizing node: t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t11: i64 = Constant<0>
Legal operand
Legally typed node: t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>

Legalizing node: t44: ch = TokenFactor t13, t15, t30
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>
Legal operand
Analyzing operand: t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>
Legal operand
Analyzing operand: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Legal operand
Legally typed node: t44: ch = TokenFactor t13, t15, t30

Legalizing node: t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t44: ch = TokenFactor t13, t15, t30
Legal operand
Analyzing operand: t43: i64 = add nsw t41, t42
Legal operand
Legally typed node: t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43

Legalizing node: t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1
Analyzing result type: ch
Legal result type
Analyzing operand: t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
Legal operand
Analyzing operand: t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
Legal operand
Legally typed node: t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1

Legalizing node: t65535: ch = handlenode t47
Analyzing result type: ch
Legal result type
Analyzing operand: t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1
Legal operand
Legally typed node: t65535: ch = handlenode t47

Type-legalized selection DAG: %bb.0 'add:entry'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
                t2: i64,ch = CopyFromReg t0, Register:i64 %0
              t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
              t4: i64,ch = CopyFromReg t0, Register:i64 %1
            t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64
            t6: i64,ch = CopyFromReg t0, Register:i64 %2
          t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64
          t8: i64,ch = CopyFromReg t0, Register:i64 %3
        t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64
        t10: i64,ch = CopyFromReg t0, Register:i64 %4
      t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64
    t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64
  t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
      t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>
      t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>
    t44: ch = TokenFactor t13, t15, t30
                t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64
                t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64
              t33: i64 = add nsw t31, t32
              t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64
            t35: i64 = add nsw t33, t34
            t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64
          t37: i64 = add nsw t35, t36
          t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64
        t39: i64 = add nsw t37, t38
        t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64
      t41: i64 = add nsw t39, t40
      t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64
    t43: i64 = add nsw t41, t42
  t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
  t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1



Legalizing: t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1
Legal node: nothing to do

Legalizing: t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
Legal node: nothing to do

Legalizing: t43: i64 = add nsw t41, t42
Legal node: nothing to do

Legalizing: t41: i64 = add nsw t39, t40
Legal node: nothing to do

Legalizing: t39: i64 = add nsw t37, t38
Legal node: nothing to do

Legalizing: t37: i64 = add nsw t35, t36
Legal node: nothing to do

Legalizing: t35: i64 = add nsw t33, t34
Legal node: nothing to do

Legalizing: t33: i64 = add nsw t31, t32
Legal node: nothing to do

Legalizing: t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64
Legalizing non-extending load operation

Legalizing: t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Legalizing: t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Legalizing: t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Legalizing: t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64
Legalizing non-extending load operation

Legalizing: t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64
Legalizing non-extending load operation

Legalizing: t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64
Legalizing non-extending load operation

Legalizing: t44: ch = TokenFactor t13, t15, t30
Legal node: nothing to do

Legalizing: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>
Legal node: nothing to do

Legalizing: t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>
Legal node: nothing to do

Legalizing: t10: i64,ch = CopyFromReg t0, Register:i64 %4
Legal node: nothing to do

Legalizing: t8: i64,ch = CopyFromReg t0, Register:i64 %3
Legal node: nothing to do

Legalizing: t6: i64,ch = CopyFromReg t0, Register:i64 %2
Legal node: nothing to do

Legalizing: t4: i64,ch = CopyFromReg t0, Register:i64 %1
Legal node: nothing to do

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %0
Legal node: nothing to do

Legalizing: t45: i64 = Register $r0

Legalizing: t29: i64 = FrameIndex<6>
Legal node: nothing to do

Legalizing: t27: i64 = FrameIndex<5>
Legal node: nothing to do

Legalizing: t25: i64 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t23: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t21: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t19: i64 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t17: i64 = undef
Legal node: nothing to do

Legalizing: t16: i64 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t14: i64 = Register %6

Legalizing: t12: i64 = Register %5

Legalizing: t11: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t9: i64 = Register %4

Legalizing: t7: i64 = Register %3

Legalizing: t5: i64 = Register %2

Legalizing: t3: i64 = Register %1

Legalizing: t1: i64 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 'add:entry'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
                t2: i64,ch = CopyFromReg t0, Register:i64 %0
              t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
              t4: i64,ch = CopyFromReg t0, Register:i64 %1
            t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64
            t6: i64,ch = CopyFromReg t0, Register:i64 %2
          t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64
          t8: i64,ch = CopyFromReg t0, Register:i64 %3
        t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64
        t10: i64,ch = CopyFromReg t0, Register:i64 %4
      t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64
    t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64
  t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
      t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>
      t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>
    t44: ch = TokenFactor t13, t15, t30
                t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64
                t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64
              t33: i64 = add nsw t31, t32
              t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64
            t35: i64 = add nsw t33, t34
            t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64
          t37: i64 = add nsw t35, t36
          t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64
        t39: i64 = add nsw t37, t38
        t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64
      t41: i64 = add nsw t39, t40
      t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64
    t43: i64 = add nsw t41, t42
  t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
  t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1



Legalizing: t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1
Legal node: nothing to do

Combining: t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1

Legalizing: t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
Legal node: nothing to do

Combining: t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43

Legalizing: t43: i64 = add nsw t41, t42
Legal node: nothing to do

Combining: t43: i64 = add nsw t41, t42

Legalizing: t41: i64 = add nsw t39, t40
Legal node: nothing to do

Combining: t41: i64 = add nsw t39, t40

Legalizing: t39: i64 = add nsw t37, t38
Legal node: nothing to do

Combining: t39: i64 = add nsw t37, t38

Legalizing: t37: i64 = add nsw t35, t36
Legal node: nothing to do

Combining: t37: i64 = add nsw t35, t36

Legalizing: t35: i64 = add nsw t33, t34
Legal node: nothing to do

Combining: t35: i64 = add nsw t33, t34

Legalizing: t33: i64 = add nsw t31, t32
Legal node: nothing to do

Combining: t33: i64 = add nsw t31, t32

Legalizing: t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64
Legalizing non-extending load operation

Combining: t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64

Legalizing: t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Combining: t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64

Legalizing: t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Combining: t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64

Legalizing: t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Combining: t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64

Legalizing: t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64
Legalizing non-extending load operation

Combining: t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64

Legalizing: t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64
Legalizing non-extending load operation

Combining: t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64

Legalizing: t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64
Legalizing non-extending load operation

Combining: t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64

Legalizing: t44: ch = TokenFactor t13, t15, t30
Legal node: nothing to do

Combining: t44: ch = TokenFactor t13, t15, t30

Legalizing: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64

Legalizing: t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64

Legalizing: t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64

Legalizing: t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64

Legalizing: t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64

Legalizing: t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64

Legalizing: t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64

Legalizing: t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>
Legal node: nothing to do

Combining: t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>

Legalizing: t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>
Legal node: nothing to do

Combining: t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>

Legalizing: t10: i64,ch = CopyFromReg t0, Register:i64 %4
Legal node: nothing to do

Combining: t10: i64,ch = CopyFromReg t0, Register:i64 %4

Legalizing: t8: i64,ch = CopyFromReg t0, Register:i64 %3
Legal node: nothing to do

Combining: t8: i64,ch = CopyFromReg t0, Register:i64 %3

Legalizing: t6: i64,ch = CopyFromReg t0, Register:i64 %2
Legal node: nothing to do

Combining: t6: i64,ch = CopyFromReg t0, Register:i64 %2

Legalizing: t4: i64,ch = CopyFromReg t0, Register:i64 %1
Legal node: nothing to do

Combining: t4: i64,ch = CopyFromReg t0, Register:i64 %1

Legalizing: t2: i64,ch = CopyFromReg t0, Register:i64 %0
Legal node: nothing to do

Combining: t2: i64,ch = CopyFromReg t0, Register:i64 %0

Legalizing: t45: i64 = Register $r0

Combining: t45: i64 = Register $r0

Legalizing: t29: i64 = FrameIndex<6>
Legal node: nothing to do

Combining: t29: i64 = FrameIndex<6>

Legalizing: t27: i64 = FrameIndex<5>
Legal node: nothing to do

Combining: t27: i64 = FrameIndex<5>

Legalizing: t25: i64 = FrameIndex<4>
Legal node: nothing to do

Combining: t25: i64 = FrameIndex<4>

Legalizing: t23: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t23: i64 = FrameIndex<3>

Legalizing: t21: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t21: i64 = FrameIndex<2>

Legalizing: t19: i64 = FrameIndex<1>
Legal node: nothing to do

Combining: t19: i64 = FrameIndex<1>

Legalizing: t17: i64 = undef
Legal node: nothing to do

Combining: t17: i64 = undef

Legalizing: t16: i64 = FrameIndex<0>
Legal node: nothing to do

Combining: t16: i64 = FrameIndex<0>

Legalizing: t14: i64 = Register %6

Combining: t14: i64 = Register %6

Legalizing: t12: i64 = Register %5

Combining: t12: i64 = Register %5

Legalizing: t11: i64 = Constant<0>
Legal node: nothing to do

Combining: t11: i64 = Constant<0>

Legalizing: t9: i64 = Register %4

Combining: t9: i64 = Register %4

Legalizing: t7: i64 = Register %3

Combining: t7: i64 = Register %3

Legalizing: t5: i64 = Register %2

Combining: t5: i64 = Register %2

Legalizing: t3: i64 = Register %1

Combining: t3: i64 = Register %1

Legalizing: t1: i64 = Register %0

Combining: t1: i64 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'add:entry'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
                t2: i64,ch = CopyFromReg t0, Register:i64 %0
              t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
              t4: i64,ch = CopyFromReg t0, Register:i64 %1
            t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64
            t6: i64,ch = CopyFromReg t0, Register:i64 %2
          t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64
          t8: i64,ch = CopyFromReg t0, Register:i64 %3
        t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64
        t10: i64,ch = CopyFromReg t0, Register:i64 %4
      t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64
    t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64
  t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
      t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>
      t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>
    t44: ch = TokenFactor t13, t15, t30
                t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64
                t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64
              t33: i64 = add nsw t31, t32
              t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64
            t35: i64 = add nsw t33, t34
            t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64
          t37: i64 = add nsw t35, t36
          t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64
        t39: i64 = add nsw t37, t38
        t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64
      t41: i64 = add nsw t39, t40
      t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64
    t43: i64 = add nsw t41, t42
  t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
  t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t47: ch = BPFISD::RET_FLAG t46, Register:i64 $r0, t46:1
ISEL: Starting pattern match
  Morphed node: t47: ch = RET Register:i64 $r0, t46, t46:1
ISEL: Match complete!

ISEL: Starting selection on root node: t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43

ISEL: Starting selection on root node: t43: i64 = add nsw t41, t42
ISEL: Starting pattern match
  Initial Opcode index to 2452
  Match failed at index 2457
  Continuing at 2468
  Match failed at index 2474
  Continuing at 2511
  Morphed node: t43: i64 = ADD_rr nsw t41, t42
ISEL: Match complete!

ISEL: Starting selection on root node: t41: i64 = add nsw t39, t40
ISEL: Starting pattern match
  Initial Opcode index to 2452
  Match failed at index 2457
  Continuing at 2468
  Match failed at index 2474
  Continuing at 2511
  Morphed node: t41: i64 = ADD_rr nsw t39, t40
ISEL: Match complete!

ISEL: Starting selection on root node: t39: i64 = add nsw t37, t38
ISEL: Starting pattern match
  Initial Opcode index to 2452
  Match failed at index 2457
  Continuing at 2468
  Match failed at index 2474
  Continuing at 2511
  Morphed node: t39: i64 = ADD_rr nsw t37, t38
ISEL: Match complete!

ISEL: Starting selection on root node: t37: i64 = add nsw t35, t36
ISEL: Starting pattern match
  Initial Opcode index to 2452
  Match failed at index 2457
  Continuing at 2468
  Match failed at index 2474
  Continuing at 2511
  Morphed node: t37: i64 = ADD_rr nsw t35, t36
ISEL: Match complete!

ISEL: Starting selection on root node: t35: i64 = add nsw t33, t34
ISEL: Starting pattern match
  Initial Opcode index to 2452
  Match failed at index 2457
  Continuing at 2468
  Match failed at index 2474
  Continuing at 2511
  Morphed node: t35: i64 = ADD_rr nsw t33, t34
ISEL: Match complete!

ISEL: Starting selection on root node: t33: i64 = add nsw t31, t32
ISEL: Starting pattern match
  Initial Opcode index to 2452
  Match failed at index 2457
  Continuing at 2468
  Match failed at index 2474
  Continuing at 2511
  Morphed node: t33: i64 = ADD_rr nsw t31, t32
ISEL: Match complete!

ISEL: Starting selection on root node: t31: i64,ch = load<(dereferenceable load (s64) from %ir.a.addr)> t30, FrameIndex:i64<0>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
Creating constant: t49: i64 = TargetConstant<0>
  Morphed node: t31: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t32: i64,ch = load<(dereferenceable load (s64) from %ir.b.addr)> t30, FrameIndex:i64<1>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Morphed node: t32: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b.addr)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t34: i64,ch = load<(dereferenceable load (s64) from %ir.c.addr)> t30, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Morphed node: t34: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c.addr)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t36: i64,ch = load<(dereferenceable load (s64) from %ir.d.addr)> t30, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Morphed node: t36: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d.addr)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t38: i64,ch = load<(dereferenceable load (s64) from %ir.e.addr)> t30, FrameIndex:i64<4>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Morphed node: t38: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e.addr)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t40: i64,ch = load<(dereferenceable load (s64) from %ir.f.addr)> t30, FrameIndex:i64<5>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Morphed node: t40: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.f.addr)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t42: i64,ch = load<(dereferenceable load (s64) from %ir.g.addr)> t30, FrameIndex:i64<6>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Morphed node: t42: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.g.addr)> TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t44: ch = TokenFactor t13, t15, t30

ISEL: Starting selection on root node: t30: ch = store<(store (s64) into %ir.g.addr)> t28, Constant:i64<0>, FrameIndex:i64<6>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t30: ch = STD<Mem:(store (s64) into %ir.g.addr)> Constant:i64<0>, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t28
ISEL: Match complete!

ISEL: Starting selection on root node: t28: ch = store<(store (s64) into %ir.f.addr)> t26, Constant:i64<0>, FrameIndex:i64<5>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t28: ch = STD<Mem:(store (s64) into %ir.f.addr)> Constant:i64<0>, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t26
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch = store<(store (s64) into %ir.e.addr)> t24, t10, FrameIndex:i64<4>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t26: ch = STD<Mem:(store (s64) into %ir.e.addr)> t10, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t24
ISEL: Match complete!

ISEL: Starting selection on root node: t24: ch = store<(store (s64) into %ir.d.addr)> t22, t8, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t24: ch = STD<Mem:(store (s64) into %ir.d.addr)> t8, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t22
ISEL: Match complete!

ISEL: Starting selection on root node: t22: ch = store<(store (s64) into %ir.c.addr)> t20, t6, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t22: ch = STD<Mem:(store (s64) into %ir.c.addr)> t6, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: ch = store<(store (s64) into %ir.b.addr)> t18, t4, FrameIndex:i64<1>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t20: ch = STD<Mem:(store (s64) into %ir.b.addr)> t4, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t18
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = store<(store (s64) into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t18: ch = STD<Mem:(store (s64) into %ir.a.addr)> t2, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch = CopyToReg t0, Register:i64 %6, Constant:i64<0>

ISEL: Starting selection on root node: t13: ch = CopyToReg t0, Register:i64 %5, Constant:i64<0>

ISEL: Starting selection on root node: t10: i64,ch = CopyFromReg t0, Register:i64 %4

ISEL: Starting selection on root node: t8: i64,ch = CopyFromReg t0, Register:i64 %3

ISEL: Starting selection on root node: t6: i64,ch = CopyFromReg t0, Register:i64 %2

ISEL: Starting selection on root node: t4: i64,ch = CopyFromReg t0, Register:i64 %1

ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %0

ISEL: Starting selection on root node: t45: i64 = Register $r0

ISEL: Starting selection on root node: t14: i64 = Register %6

ISEL: Starting selection on root node: t12: i64 = Register %5

ISEL: Starting selection on root node: t11: i64 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 3405
  TypeSwitch[i64] from 3406 to 3409
  Morphed node: t11: i64 = MOV_ri TargetConstant:i64<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t9: i64 = Register %4

ISEL: Starting selection on root node: t7: i64 = Register %3

ISEL: Starting selection on root node: t5: i64 = Register %2

ISEL: Starting selection on root node: t3: i64 = Register %1

ISEL: Starting selection on root node: t1: i64 = Register %0

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'add:entry'
SelectionDAG has 48 nodes:
  t0: ch = EntryToken
  t11: i64 = MOV_ri TargetConstant:i64<0>
        t10: i64,ch = CopyFromReg t0, Register:i64 %4
          t8: i64,ch = CopyFromReg t0, Register:i64 %3
            t6: i64,ch = CopyFromReg t0, Register:i64 %2
              t4: i64,ch = CopyFromReg t0, Register:i64 %1
                t2: i64,ch = CopyFromReg t0, Register:i64 %0
              t18: ch = STD<Mem:(store (s64) into %ir.a.addr)> t2, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0
            t20: ch = STD<Mem:(store (s64) into %ir.b.addr)> t4, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t18
          t22: ch = STD<Mem:(store (s64) into %ir.c.addr)> t6, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t20
        t24: ch = STD<Mem:(store (s64) into %ir.d.addr)> t8, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t22
      t26: ch = STD<Mem:(store (s64) into %ir.e.addr)> t10, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t24
    t28: ch = STD<Mem:(store (s64) into %ir.f.addr)> t11, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t26
  t30: ch = STD<Mem:(store (s64) into %ir.g.addr)> t11, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t28
      t13: ch = CopyToReg t0, Register:i64 %5, t11
      t15: ch = CopyToReg t0, Register:i64 %6, t11
    t44: ch = TokenFactor t13, t15, t30
                t31: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t30
                t32: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b.addr)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t30
              t33: i64 = ADD_rr nsw t31, t32
              t34: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c.addr)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t30
            t35: i64 = ADD_rr nsw t33, t34
            t36: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d.addr)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t30
          t37: i64 = ADD_rr nsw t35, t36
          t38: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e.addr)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t30
        t39: i64 = ADD_rr nsw t37, t38
        t40: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.f.addr)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t30
      t41: i64 = ADD_rr nsw t39, t40
      t42: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.g.addr)> TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t30
    t43: i64 = ADD_rr nsw t41, t42
  t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43
  t47: ch = RET Register:i64 $r0, t46, t46:1


********** List Scheduling %bb.0 'entry' **********
SU(0): t47: ch = RET Register:i64 $r0, t46, t46:1

    t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 15
  Height             : 0
  Predecessors:
    SU(27): Ord  Latency=0 Barrier
    SU(1): Data Latency=1
SU(1): t43: i64 = ADD_rr nsw t41, t42

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 14
  Height             : 1
  Predecessors:
    SU(16): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t42: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.g.addr)> TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t30

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 2
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Data Latency=1
SU(3): t30: ch = STD<Mem:(store (s64) into %ir.g.addr)> t11, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t28

  # preds left       : 2
  # succs left       : 8
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 8
  Predecessors:
    SU(15): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(19): Ord  Latency=1 Barrier
    SU(21): Ord  Latency=1 Barrier
    SU(23): Ord  Latency=1 Barrier
    SU(25): Ord  Latency=1 Barrier
    SU(26): Ord  Latency=1 Barrier
    SU(27): Ord  Latency=1 Barrier
SU(4): t28: ch = STD<Mem:(store (s64) into %ir.f.addr)> t11, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t26

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 9
  Predecessors:
    SU(15): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(3): Ord  Latency=1 Barrier
SU(5): t26: ch = STD<Mem:(store (s64) into %ir.e.addr)> t10, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t24

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 10
  Predecessors:
    SU(14): Data Latency=1
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(6): t24: ch = STD<Mem:(store (s64) into %ir.d.addr)> t8, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t22

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 11
  Predecessors:
    SU(13): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(7): t22: ch = STD<Mem:(store (s64) into %ir.c.addr)> t6, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t20

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 12
  Predecessors:
    SU(12): Data Latency=1
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(8): t20: ch = STD<Mem:(store (s64) into %ir.b.addr)> t4, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t18

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 13
  Predecessors:
    SU(11): Data Latency=1
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(9): t18: ch = STD<Mem:(store (s64) into %ir.a.addr)> t2, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 14
  Predecessors:
    SU(10): Data Latency=1
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(10): t2: i64,ch = CopyFromReg t0, Register:i64 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 15
  Successors:
    SU(9): Data Latency=1
SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 14
  Successors:
    SU(8): Data Latency=1
SU(12): t6: i64,ch = CopyFromReg t0, Register:i64 %2

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 13
  Successors:
    SU(7): Data Latency=1
SU(13): t8: i64,ch = CopyFromReg t0, Register:i64 %3

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 12
  Successors:
    SU(6): Data Latency=1
SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 11
  Successors:
    SU(5): Data Latency=1
SU(15): t11: i64 = MOV_ri TargetConstant:i64<0>

  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 10
  Successors:
    SU(3): Data Latency=1
    SU(4): Data Latency=1
    SU(28): Data Latency=1
    SU(29): Data Latency=1
SU(16): t41: i64 = ADD_rr nsw t39, t40

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 13
  Height             : 2
  Predecessors:
    SU(18): Data Latency=1
    SU(17): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(17): t40: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.f.addr)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t30

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 3
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(16): Data Latency=1
SU(18): t39: i64 = ADD_rr nsw t37, t38

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 12
  Height             : 3
  Predecessors:
    SU(20): Data Latency=1
    SU(19): Data Latency=1
  Successors:
    SU(16): Data Latency=1
SU(19): t38: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e.addr)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t30

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 4
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(18): Data Latency=1
SU(20): t37: i64 = ADD_rr nsw t35, t36

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 11
  Height             : 4
  Predecessors:
    SU(22): Data Latency=1
    SU(21): Data Latency=1
  Successors:
    SU(18): Data Latency=1
SU(21): t36: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d.addr)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t30

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 5
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(20): Data Latency=1
SU(22): t35: i64 = ADD_rr nsw t33, t34

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 10
  Height             : 5
  Predecessors:
    SU(24): Data Latency=1
    SU(23): Data Latency=1
  Successors:
    SU(20): Data Latency=1
SU(23): t34: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c.addr)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t30

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 6
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(22): Data Latency=1
SU(24): t33: i64 = ADD_rr nsw t31, t32

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 9
  Height             : 6
  Predecessors:
    SU(26): Data Latency=1
    SU(25): Data Latency=1
  Successors:
    SU(22): Data Latency=1
SU(25): t32: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b.addr)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t30

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 7
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(24): Data Latency=1
SU(26): t31: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t30

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 8
  Height             : 7
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(24): Data Latency=1
SU(27): t44: ch = TokenFactor t13, t15, t30

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(29): Ord  Latency=1 Barrier
    SU(28): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=0 Barrier
SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(15): Data Latency=1
  Successors:
    SU(27): Ord  Latency=1 Barrier
SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(15): Data Latency=1
  Successors:
    SU(27): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t47: ch = RET Register:i64 $r0, t46, t46:1

    t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43


*** Scheduling [0]: SU(0): t47: ch = RET Register:i64 $r0, t46, t46:1

    t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43


Examining Available:
Height 0: SU(27): t44: ch = TokenFactor t13, t15, t30

Height 1: SU(1): t43: i64 = ADD_rr nsw t41, t42


*** Scheduling [1]: SU(27): t44: ch = TokenFactor t13, t15, t30


Examining Available:
Height 1: SU(1): t43: i64 = ADD_rr nsw t41, t42

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [2]: SU(1): t43: i64 = ADD_rr nsw t41, t42


Examining Available:
Height 3: SU(2): t42: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.g.addr)> TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t30

Height 3: SU(16): t41: i64 = ADD_rr nsw t39, t40

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [3]: SU(2): t42: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.g.addr)> TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t30


Examining Available:
Height 3: SU(16): t41: i64 = ADD_rr nsw t39, t40

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [4]: SU(16): t41: i64 = ADD_rr nsw t39, t40


Examining Available:
Height 5: SU(17): t40: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.f.addr)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t30

Height 5: SU(18): t39: i64 = ADD_rr nsw t37, t38

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [5]: SU(17): t40: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.f.addr)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t30


Examining Available:
Height 5: SU(18): t39: i64 = ADD_rr nsw t37, t38

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [6]: SU(18): t39: i64 = ADD_rr nsw t37, t38


Examining Available:
Height 7: SU(19): t38: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e.addr)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t30

Height 7: SU(20): t37: i64 = ADD_rr nsw t35, t36

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [7]: SU(19): t38: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e.addr)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t30


Examining Available:
Height 7: SU(20): t37: i64 = ADD_rr nsw t35, t36

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [8]: SU(20): t37: i64 = ADD_rr nsw t35, t36


Examining Available:
Height 9: SU(21): t36: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d.addr)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t30

Height 9: SU(22): t35: i64 = ADD_rr nsw t33, t34

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [9]: SU(21): t36: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d.addr)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t30


Examining Available:
Height 9: SU(22): t35: i64 = ADD_rr nsw t33, t34

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [10]: SU(22): t35: i64 = ADD_rr nsw t33, t34


Examining Available:
Height 11: SU(23): t34: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c.addr)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t30

Height 11: SU(24): t33: i64 = ADD_rr nsw t31, t32

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [11]: SU(23): t34: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c.addr)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t30


Examining Available:
Height 11: SU(24): t33: i64 = ADD_rr nsw t31, t32

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [12]: SU(24): t33: i64 = ADD_rr nsw t31, t32


Examining Available:
Height 13: SU(25): t32: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b.addr)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t30

Height 13: SU(26): t31: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t30

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [13]: SU(25): t32: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b.addr)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t30


Examining Available:
Height 13: SU(26): t31: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t30

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [14]: SU(26): t31: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t30


Examining Available:
Height 15: SU(3): t30: ch = STD<Mem:(store (s64) into %ir.g.addr)> t11, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t28

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [15]: SU(3): t30: ch = STD<Mem:(store (s64) into %ir.g.addr)> t11, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t28


Examining Available:
Height 16: SU(4): t28: ch = STD<Mem:(store (s64) into %ir.f.addr)> t11, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t26

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [16]: SU(4): t28: ch = STD<Mem:(store (s64) into %ir.f.addr)> t11, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t26


Examining Available:
Height 17: SU(5): t26: ch = STD<Mem:(store (s64) into %ir.e.addr)> t10, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t24

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [17]: SU(5): t26: ch = STD<Mem:(store (s64) into %ir.e.addr)> t10, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t24


Examining Available:
Height 18: SU(6): t24: ch = STD<Mem:(store (s64) into %ir.d.addr)> t8, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t22

Height 18: SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [18]: SU(6): t24: ch = STD<Mem:(store (s64) into %ir.d.addr)> t8, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t22


Examining Available:
Height 19: SU(7): t22: ch = STD<Mem:(store (s64) into %ir.c.addr)> t6, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t20

Height 19: SU(13): t8: i64,ch = CopyFromReg t0, Register:i64 %3

Height 18: SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [19]: SU(7): t22: ch = STD<Mem:(store (s64) into %ir.c.addr)> t6, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t20


Examining Available:
Height 20: SU(8): t20: ch = STD<Mem:(store (s64) into %ir.b.addr)> t4, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t18

Height 20: SU(12): t6: i64,ch = CopyFromReg t0, Register:i64 %2

Height 19: SU(13): t8: i64,ch = CopyFromReg t0, Register:i64 %3

Height 18: SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [20]: SU(8): t20: ch = STD<Mem:(store (s64) into %ir.b.addr)> t4, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t18


Examining Available:
Height 21: SU(9): t18: ch = STD<Mem:(store (s64) into %ir.a.addr)> t2, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0

Height 21: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %1

Height 20: SU(12): t6: i64,ch = CopyFromReg t0, Register:i64 %2

Height 19: SU(13): t8: i64,ch = CopyFromReg t0, Register:i64 %3

Height 18: SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [21]: SU(9): t18: ch = STD<Mem:(store (s64) into %ir.a.addr)> t2, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0


Examining Available:
Height 22: SU(10): t2: i64,ch = CopyFromReg t0, Register:i64 %0

Height 21: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %1

Height 20: SU(12): t6: i64,ch = CopyFromReg t0, Register:i64 %2

Height 19: SU(13): t8: i64,ch = CopyFromReg t0, Register:i64 %3

Height 18: SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [22]: SU(10): t2: i64,ch = CopyFromReg t0, Register:i64 %0


Examining Available:
Height 21: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %1

Height 20: SU(12): t6: i64,ch = CopyFromReg t0, Register:i64 %2

Height 19: SU(13): t8: i64,ch = CopyFromReg t0, Register:i64 %3

Height 18: SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [23]: SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %1


Examining Available:
Height 20: SU(12): t6: i64,ch = CopyFromReg t0, Register:i64 %2

Height 19: SU(13): t8: i64,ch = CopyFromReg t0, Register:i64 %3

Height 18: SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [24]: SU(12): t6: i64,ch = CopyFromReg t0, Register:i64 %2


Examining Available:
Height 19: SU(13): t8: i64,ch = CopyFromReg t0, Register:i64 %3

Height 18: SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [25]: SU(13): t8: i64,ch = CopyFromReg t0, Register:i64 %3


Examining Available:
Height 18: SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4

Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [26]: SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4


Examining Available:
Height 2: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [27]: SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11


Examining Available:
Height 2: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


*** Scheduling [28]: SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11


Examining Available:
Height 29: SU(15): t11: i64 = MOV_ri TargetConstant:i64<0>


*** Scheduling [29]: SU(15): t11: i64 = MOV_ri TargetConstant:i64<0>

*** Final schedule ***
SU(15): t11: i64 = MOV_ri TargetConstant:i64<0>

SU(28): t15: ch = CopyToReg t0, Register:i64 %6, t11

SU(29): t13: ch = CopyToReg t0, Register:i64 %5, t11

SU(14): t10: i64,ch = CopyFromReg t0, Register:i64 %4

SU(13): t8: i64,ch = CopyFromReg t0, Register:i64 %3

SU(12): t6: i64,ch = CopyFromReg t0, Register:i64 %2

SU(11): t4: i64,ch = CopyFromReg t0, Register:i64 %1

SU(10): t2: i64,ch = CopyFromReg t0, Register:i64 %0

SU(9): t18: ch = STD<Mem:(store (s64) into %ir.a.addr)> t2, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0

SU(8): t20: ch = STD<Mem:(store (s64) into %ir.b.addr)> t4, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t18

SU(7): t22: ch = STD<Mem:(store (s64) into %ir.c.addr)> t6, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t20

SU(6): t24: ch = STD<Mem:(store (s64) into %ir.d.addr)> t8, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t22

SU(5): t26: ch = STD<Mem:(store (s64) into %ir.e.addr)> t10, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t24

SU(4): t28: ch = STD<Mem:(store (s64) into %ir.f.addr)> t11, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t26

SU(3): t30: ch = STD<Mem:(store (s64) into %ir.g.addr)> t11, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t28

SU(26): t31: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t30

SU(25): t32: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b.addr)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t30

SU(24): t33: i64 = ADD_rr nsw t31, t32

SU(23): t34: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c.addr)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t30

SU(22): t35: i64 = ADD_rr nsw t33, t34

SU(21): t36: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d.addr)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t30

SU(20): t37: i64 = ADD_rr nsw t35, t36

SU(19): t38: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e.addr)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t30

SU(18): t39: i64 = ADD_rr nsw t37, t38

SU(17): t40: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.f.addr)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t30

SU(16): t41: i64 = ADD_rr nsw t39, t40

SU(2): t42: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.g.addr)> TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t30

SU(1): t43: i64 = ADD_rr nsw t41, t42

SU(27): t44: ch = TokenFactor t13, t15, t30

SU(0): t47: ch = RET Register:i64 $r0, t46, t46:1

    t46: ch,glue = CopyToReg t44, Register:i64 $r0, t43


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function add: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP]
  fi#1: size=8, align=8, at location [SP]
  fi#2: size=8, align=8, at location [SP]
  fi#3: size=8, align=8, at location [SP]
  fi#4: size=8, align=8, at location [SP]
  fi#5: size=8, align=8, at location [SP]
  fi#6: size=8, align=8, at location [SP]
Function Live Ins: $r1 in %0, $r2 in %1, $r3 in %2, $r4 in %3, $r5 in %4

bb.0.entry:
  liveins: $r1, $r2, $r3, $r4, $r5
  %4:gpr = COPY $r5
  %3:gpr = COPY $r4
  %2:gpr = COPY $r3
  %1:gpr = COPY $r2
  %0:gpr = COPY $r1
  %6:gpr = MOV_ri 0
  %5:gpr = COPY %6:gpr
  STD %0:gpr, %stack.0.a.addr, 0 :: (store (s64) into %ir.a.addr)
  STD %1:gpr, %stack.1.b.addr, 0 :: (store (s64) into %ir.b.addr)
  STD %2:gpr, %stack.2.c.addr, 0 :: (store (s64) into %ir.c.addr)
  STD %3:gpr, %stack.3.d.addr, 0 :: (store (s64) into %ir.d.addr)
  STD %4:gpr, %stack.4.e.addr, 0 :: (store (s64) into %ir.e.addr)
  STD %6:gpr, %stack.5.f.addr, 0 :: (store (s64) into %ir.f.addr)
  STD %6:gpr, %stack.6.g.addr, 0 :: (store (s64) into %ir.g.addr)
  %7:gpr = LDD %stack.0.a.addr, 0 :: (dereferenceable load (s64) from %ir.a.addr)
  %8:gpr = LDD %stack.1.b.addr, 0 :: (dereferenceable load (s64) from %ir.b.addr)
  %9:gpr = nsw ADD_rr %7:gpr(tied-def 0), killed %8:gpr
  %10:gpr = LDD %stack.2.c.addr, 0 :: (dereferenceable load (s64) from %ir.c.addr)
  %11:gpr = nsw ADD_rr %9:gpr(tied-def 0), killed %10:gpr
  %12:gpr = LDD %stack.3.d.addr, 0 :: (dereferenceable load (s64) from %ir.d.addr)
  %13:gpr = nsw ADD_rr %11:gpr(tied-def 0), killed %12:gpr
  %14:gpr = LDD %stack.4.e.addr, 0 :: (dereferenceable load (s64) from %ir.e.addr)
  %15:gpr = nsw ADD_rr %13:gpr(tied-def 0), killed %14:gpr
  %16:gpr = LDD %stack.5.f.addr, 0 :: (dereferenceable load (s64) from %ir.f.addr)
  %17:gpr = nsw ADD_rr %15:gpr(tied-def 0), killed %16:gpr
  %18:gpr = LDD %stack.6.g.addr, 0 :: (dereferenceable load (s64) from %ir.g.addr)
  %19:gpr = nsw ADD_rr %17:gpr(tied-def 0), killed %18:gpr
  $r0 = COPY %19:gpr
  RET implicit $r0

# End machine code for function add.


Restoring optimization level for Function add
	Before: -O0 ; After: -O2
Skipping pass 'Two-Address instruction pass' on function add
********** REWRITING TWO-ADDR INSTRS **********
********** Function: add
	%9:gpr = nsw ADD_rr %7:gpr(tied-def 0), killed %8:gpr
		prepend:	%9:gpr = COPY %7:gpr
		rewrite to:	%9:gpr = nsw ADD_rr %9:gpr(tied-def 0), killed %8:gpr
	%11:gpr = nsw ADD_rr %9:gpr(tied-def 0), killed %10:gpr
		prepend:	%11:gpr = COPY %9:gpr
		rewrite to:	%11:gpr = nsw ADD_rr %11:gpr(tied-def 0), killed %10:gpr
	%13:gpr = nsw ADD_rr %11:gpr(tied-def 0), killed %12:gpr
		prepend:	%13:gpr = COPY %11:gpr
		rewrite to:	%13:gpr = nsw ADD_rr %13:gpr(tied-def 0), killed %12:gpr
	%15:gpr = nsw ADD_rr %13:gpr(tied-def 0), killed %14:gpr
		prepend:	%15:gpr = COPY %13:gpr
		rewrite to:	%15:gpr = nsw ADD_rr %15:gpr(tied-def 0), killed %14:gpr
	%17:gpr = nsw ADD_rr %15:gpr(tied-def 0), killed %16:gpr
		prepend:	%17:gpr = COPY %15:gpr
		rewrite to:	%17:gpr = nsw ADD_rr %17:gpr(tied-def 0), killed %16:gpr
	%19:gpr = nsw ADD_rr %17:gpr(tied-def 0), killed %18:gpr
		prepend:	%19:gpr = COPY %17:gpr
		rewrite to:	%19:gpr = nsw ADD_rr %19:gpr(tied-def 0), killed %18:gpr
********** FAST REGISTER ALLOCATION **********
********** Function: add

Allocating bb.0.entry:
  liveins: $r1, $r2, $r3, $r4, $r5
  %4:gpr = COPY $r5
  %3:gpr = COPY $r4
  %2:gpr = COPY $r3
  %1:gpr = COPY $r2
  %0:gpr = COPY $r1
  %6:gpr = MOV_ri 0
  %5:gpr = COPY %6:gpr
  STD %0:gpr, %stack.0.a.addr, 0 :: (store (s64) into %ir.a.addr)
  STD %1:gpr, %stack.1.b.addr, 0 :: (store (s64) into %ir.b.addr)
  STD %2:gpr, %stack.2.c.addr, 0 :: (store (s64) into %ir.c.addr)
  STD %3:gpr, %stack.3.d.addr, 0 :: (store (s64) into %ir.d.addr)
  STD %4:gpr, %stack.4.e.addr, 0 :: (store (s64) into %ir.e.addr)
  STD %6:gpr, %stack.5.f.addr, 0 :: (store (s64) into %ir.f.addr)
  STD %6:gpr, %stack.6.g.addr, 0 :: (store (s64) into %ir.g.addr)
  %7:gpr = LDD %stack.0.a.addr, 0 :: (dereferenceable load (s64) from %ir.a.addr)
  %8:gpr = LDD %stack.1.b.addr, 0 :: (dereferenceable load (s64) from %ir.b.addr)
  %9:gpr = COPY %7:gpr
  %9:gpr = nsw ADD_rr %9:gpr(tied-def 0), killed %8:gpr
  %10:gpr = LDD %stack.2.c.addr, 0 :: (dereferenceable load (s64) from %ir.c.addr)
  %11:gpr = COPY %9:gpr
  %11:gpr = nsw ADD_rr %11:gpr(tied-def 0), killed %10:gpr
  %12:gpr = LDD %stack.3.d.addr, 0 :: (dereferenceable load (s64) from %ir.d.addr)
  %13:gpr = COPY %11:gpr
  %13:gpr = nsw ADD_rr %13:gpr(tied-def 0), killed %12:gpr
  %14:gpr = LDD %stack.4.e.addr, 0 :: (dereferenceable load (s64) from %ir.e.addr)
  %15:gpr = COPY %13:gpr
  %15:gpr = nsw ADD_rr %15:gpr(tied-def 0), killed %14:gpr
  %16:gpr = LDD %stack.5.f.addr, 0 :: (dereferenceable load (s64) from %ir.f.addr)
  %17:gpr = COPY %15:gpr
  %17:gpr = nsw ADD_rr %17:gpr(tied-def 0), killed %16:gpr
  %18:gpr = LDD %stack.6.g.addr, 0 :: (dereferenceable load (s64) from %ir.g.addr)
  %19:gpr = COPY %17:gpr
  %19:gpr = nsw ADD_rr %19:gpr(tied-def 0), killed %18:gpr
  $r0 = COPY %19:gpr
  RET implicit $r0

>> RET implicit $r0
Regs:
<< RET implicit killed $r0

>> $r0 = COPY %19:gpr
Regs:
Freeing $r0:
Search register for %19 in class GPR with hint $r0
	Preferred Register 1: $r0
Assigning %19 to $r0
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> %19:gpr = nsw ADD_rr %19:gpr(tied-def 0), killed %18:gpr
Regs:
Need to assign livethroughs
Allocating %19:gpr
In def of %19 use existing assignment to $r0
Search register for %18 in class GPR with hint $noreg
AllocationOrder(GPR) = [ $r1 $r2 $r3 $r4 $r5 $r0 $r6 $r7 $r8 $r9 ]
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %18 to $r1
<< $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1

>> %19:gpr = COPY %17:gpr
Regs: W1=%18
In def of %19 use existing assignment to $r0
Freeing $r0: %19
Search register for %17 in class GPR with hint $r0
	Preferred Register 1: $r0
Assigning %17 to $r0
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> %18:gpr = LDD %stack.6.g.addr, 0 :: (dereferenceable load (s64) from %ir.g.addr)
Regs: W1=%18
In def of %18 use existing assignment to $r1
Freeing $r1: %18
<< $r1 = LDD %stack.6.g.addr, 0 :: (dereferenceable load (s64) from %ir.g.addr)

>> %17:gpr = nsw ADD_rr %17:gpr(tied-def 0), killed %16:gpr
Regs:
Need to assign livethroughs
Allocating %17:gpr
In def of %17 use existing assignment to $r0
Search register for %16 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %16 to $r1
<< $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1

>> %17:gpr = COPY %15:gpr
Regs: W1=%16
In def of %17 use existing assignment to $r0
Freeing $r0: %17
Search register for %15 in class GPR with hint $r0
	Preferred Register 1: $r0
Assigning %15 to $r0
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> %16:gpr = LDD %stack.5.f.addr, 0 :: (dereferenceable load (s64) from %ir.f.addr)
Regs: W1=%16
In def of %16 use existing assignment to $r1
Freeing $r1: %16
<< $r1 = LDD %stack.5.f.addr, 0 :: (dereferenceable load (s64) from %ir.f.addr)

>> %15:gpr = nsw ADD_rr %15:gpr(tied-def 0), killed %14:gpr
Regs:
Need to assign livethroughs
Allocating %15:gpr
In def of %15 use existing assignment to $r0
Search register for %14 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %14 to $r1
<< $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1

>> %15:gpr = COPY %13:gpr
Regs: W1=%14
In def of %15 use existing assignment to $r0
Freeing $r0: %15
Search register for %13 in class GPR with hint $r0
	Preferred Register 1: $r0
Assigning %13 to $r0
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> %14:gpr = LDD %stack.4.e.addr, 0 :: (dereferenceable load (s64) from %ir.e.addr)
Regs: W1=%14
In def of %14 use existing assignment to $r1
Freeing $r1: %14
<< $r1 = LDD %stack.4.e.addr, 0 :: (dereferenceable load (s64) from %ir.e.addr)

>> %13:gpr = nsw ADD_rr %13:gpr(tied-def 0), killed %12:gpr
Regs:
Need to assign livethroughs
Allocating %13:gpr
In def of %13 use existing assignment to $r0
Search register for %12 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %12 to $r1
<< $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1

>> %13:gpr = COPY %11:gpr
Regs: W1=%12
In def of %13 use existing assignment to $r0
Freeing $r0: %13
Search register for %11 in class GPR with hint $r0
	Preferred Register 1: $r0
Assigning %11 to $r0
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> %12:gpr = LDD %stack.3.d.addr, 0 :: (dereferenceable load (s64) from %ir.d.addr)
Regs: W1=%12
In def of %12 use existing assignment to $r1
Freeing $r1: %12
<< $r1 = LDD %stack.3.d.addr, 0 :: (dereferenceable load (s64) from %ir.d.addr)

>> %11:gpr = nsw ADD_rr %11:gpr(tied-def 0), killed %10:gpr
Regs:
Need to assign livethroughs
Allocating %11:gpr
In def of %11 use existing assignment to $r0
Search register for %10 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %10 to $r1
<< $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1

>> %11:gpr = COPY %9:gpr
Regs: W1=%10
In def of %11 use existing assignment to $r0
Freeing $r0: %11
Search register for %9 in class GPR with hint $r0
	Preferred Register 1: $r0
Assigning %9 to $r0
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> %10:gpr = LDD %stack.2.c.addr, 0 :: (dereferenceable load (s64) from %ir.c.addr)
Regs: W1=%10
In def of %10 use existing assignment to $r1
Freeing $r1: %10
<< $r1 = LDD %stack.2.c.addr, 0 :: (dereferenceable load (s64) from %ir.c.addr)

>> %9:gpr = nsw ADD_rr %9:gpr(tied-def 0), killed %8:gpr
Regs:
Need to assign livethroughs
Allocating %9:gpr
In def of %9 use existing assignment to $r0
Search register for %8 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %8 to $r1
<< $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1

>> %9:gpr = COPY %7:gpr
Regs: W1=%8
In def of %9 use existing assignment to $r0
Freeing $r0: %9
Search register for %7 in class GPR with hint $r0
	Preferred Register 1: $r0
Assigning %7 to $r0
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> %8:gpr = LDD %stack.1.b.addr, 0 :: (dereferenceable load (s64) from %ir.b.addr)
Regs: W1=%8
In def of %8 use existing assignment to $r1
Freeing $r1: %8
<< $r1 = LDD %stack.1.b.addr, 0 :: (dereferenceable load (s64) from %ir.b.addr)

>> %7:gpr = LDD %stack.0.a.addr, 0 :: (dereferenceable load (s64) from %ir.a.addr)
Regs:
In def of %7 use existing assignment to $r0
Freeing $r0: %7
<< $r0 = LDD %stack.0.a.addr, 0 :: (dereferenceable load (s64) from %ir.a.addr)

>> STD %6:gpr, %stack.6.g.addr, 0 :: (store (s64) into %ir.g.addr)
Regs:
Search register for %6 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %6 to $r1
<< STD killed $r1, %stack.6.g.addr, 0 :: (store (s64) into %ir.g.addr)

>> STD %6:gpr, %stack.5.f.addr, 0 :: (store (s64) into %ir.f.addr)
Regs: W1=%6
<< STD $r1, %stack.5.f.addr, 0 :: (store (s64) into %ir.f.addr)

>> STD %4:gpr, %stack.4.e.addr, 0 :: (store (s64) into %ir.e.addr)
Regs: W1=%6
Search register for %4 in class GPR with hint $noreg
	Preferred Register 0: $r5
Assigning %4 to $r5
<< STD killed $r5, %stack.4.e.addr, 0 :: (store (s64) into %ir.e.addr)

>> STD %3:gpr, %stack.3.d.addr, 0 :: (store (s64) into %ir.d.addr)
Regs: W1=%6 W5=%4
Search register for %3 in class GPR with hint $noreg
	Preferred Register 0: $r4
Assigning %3 to $r4
<< STD killed $r4, %stack.3.d.addr, 0 :: (store (s64) into %ir.d.addr)

>> STD %2:gpr, %stack.2.c.addr, 0 :: (store (s64) into %ir.c.addr)
Regs: W1=%6 W4=%3 W5=%4
Search register for %2 in class GPR with hint $noreg
	Preferred Register 0: $r3
Assigning %2 to $r3
<< STD killed $r3, %stack.2.c.addr, 0 :: (store (s64) into %ir.c.addr)

>> STD %1:gpr, %stack.1.b.addr, 0 :: (store (s64) into %ir.b.addr)
Regs: W1=%6 W3=%2 W4=%3 W5=%4
Search register for %1 in class GPR with hint $noreg
	Preferred Register 0: $r2
Assigning %1 to $r2
<< STD killed $r2, %stack.1.b.addr, 0 :: (store (s64) into %ir.b.addr)

>> STD %0:gpr, %stack.0.a.addr, 0 :: (store (s64) into %ir.a.addr)
Regs: W1=%6 W2=%1 W3=%2 W4=%3 W5=%4
Search register for %0 in class GPR with hint $noreg
	Preferred Register 1: $r1 occupied
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 80
	Register: $r3 Cost: 100 BestCost: 80
	Register: $r4 Cost: 100 BestCost: 80
	Register: $r5 Cost: 100 BestCost: 80
	Register: $r0 Cost: 0 BestCost: 80
Assigning %0 to $r0
<< STD killed $r0, %stack.0.a.addr, 0 :: (store (s64) into %ir.a.addr)

>> %5:gpr = COPY %6:gpr
Regs: W1=%6 W2=%1 W3=%2 W4=%3 W5=%4
Search register for %5 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 100 BestCost: 100
	Register: $r3 Cost: 100 BestCost: 100
	Register: $r4 Cost: 100 BestCost: 100
	Register: $r5 Cost: 100 BestCost: 100
	Register: $r0 Cost: 100 BestCost: 100
	Register: $r6 Cost: 0 BestCost: 100
Assigning %5 to $r6
Freeing $r6: %5
<< dead $r6 = COPY $r1

>> %6:gpr = MOV_ri 0
Regs: W1=%6 W2=%1 W3=%2 W4=%3 W5=%4
In def of %6 use existing assignment to $r1
Freeing $r1: %6
<< $r1 = MOV_ri 0

>> %0:gpr = COPY $r1
Regs: W2=%1 W3=%2 W4=%3 W5=%4
In def of %0 use existing assignment to $r0
Freeing $r0: %0
<< $r0 = COPY killed $r1

>> %1:gpr = COPY $r2
Regs: W1[P] W2=%1 W3=%2 W4=%3 W5=%4
In def of %1 use existing assignment to $r2
Freeing $r2: %1
<< $r2 = COPY killed $r2
Mark identity copy for removal

>> %2:gpr = COPY $r3
Regs: W1[P] W2[P] W3=%2 W4=%3 W5=%4
In def of %2 use existing assignment to $r3
Freeing $r3: %2
<< $r3 = COPY killed $r3
Mark identity copy for removal

>> %3:gpr = COPY $r4
Regs: W1[P] W2[P] W3[P] W4=%3 W5=%4
In def of %3 use existing assignment to $r4
Freeing $r4: %3
<< $r4 = COPY killed $r4
Mark identity copy for removal

>> %4:gpr = COPY $r5
Regs: W1[P] W2[P] W3[P] W4[P] W5=%4
In def of %4 use existing assignment to $r5
Freeing $r5: %4
<< $r5 = COPY killed $r5
Mark identity copy for removal
Begin Regs: W1[P] W2[P] W3[P] W4[P] W5[P]
Loading live registers at begin of block.
bb.0.entry:
  liveins: $r1, $r2, $r3, $r4, $r5
  $r0 = COPY killed $r1
  $r1 = MOV_ri 0
  dead $r6 = COPY $r1
  STD killed $r0, %stack.0.a.addr, 0 :: (store (s64) into %ir.a.addr)
  STD killed $r2, %stack.1.b.addr, 0 :: (store (s64) into %ir.b.addr)
  STD killed $r3, %stack.2.c.addr, 0 :: (store (s64) into %ir.c.addr)
  STD killed $r4, %stack.3.d.addr, 0 :: (store (s64) into %ir.d.addr)
  STD killed $r5, %stack.4.e.addr, 0 :: (store (s64) into %ir.e.addr)
  STD $r1, %stack.5.f.addr, 0 :: (store (s64) into %ir.f.addr)
  STD killed $r1, %stack.6.g.addr, 0 :: (store (s64) into %ir.g.addr)
  $r0 = LDD %stack.0.a.addr, 0 :: (dereferenceable load (s64) from %ir.a.addr)
  $r1 = LDD %stack.1.b.addr, 0 :: (dereferenceable load (s64) from %ir.b.addr)
  $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1
  $r1 = LDD %stack.2.c.addr, 0 :: (dereferenceable load (s64) from %ir.c.addr)
  $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1
  $r1 = LDD %stack.3.d.addr, 0 :: (dereferenceable load (s64) from %ir.d.addr)
  $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1
  $r1 = LDD %stack.4.e.addr, 0 :: (dereferenceable load (s64) from %ir.e.addr)
  $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1
  $r1 = LDD %stack.5.f.addr, 0 :: (dereferenceable load (s64) from %ir.f.addr)
  $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1
  $r1 = LDD %stack.6.g.addr, 0 :: (dereferenceable load (s64) from %ir.g.addr)
  $r0 = nsw ADD_rr $r0(tied-def 0), killed $r1
  RET implicit killed $r0
Skipping pass 'Fixup Statepoint Caller Saved' on function add
alloc FI(0) at SP[-8]
alloc FI(1) at SP[-16]
alloc FI(2) at SP[-24]
alloc FI(3) at SP[-32]
alloc FI(4) at SP[-40]
alloc FI(5) at SP[-48]
alloc FI(6) at SP[-56]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: add
real copy:   $r0 = COPY killed $r1
replaced by: $r0 = MOV_rr killed $r1
dead copy: dead $r6 = COPY $r1
replaced by: dead $r6 = KILL $r1
Skipping pass 'BPF PreEmit Checking' on function add
********** COMPUTING STACKMAP LIVENESS: add **********

Debug Range Extension
[SafeStack] Function: main
[SafeStack]     safestack is not requested for this function
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry
---- Branch Probability Info : main ----

Computing probabilities for entry
Skipping pass 'BPF DAG->DAG Pattern Instruction Selection' on function main

Changing optimization level for Function main
	Before: -O2 ; After: -O0
	FastISel is enabled



=== main
Enabling fast-isel
Creating constant: t1: i32 = Constant<0>
Creating constant: t3: i64 = Constant<0>
Creating new node: t4: i64 = undef
Creating new node: t5: ch = store<(store (s32) into %ir.retval)> t0, Constant:i32<0>, FrameIndex:i64<0>, undef:i64
Creating constant: t6: i64 = Constant<9>
Creating new node: t8: ch = store<(store (s64) into %ir.a)> t5, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
Creating constant: t9: i64 = Constant<10>
Creating new node: t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
Creating new node: t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
Creating new node: t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
Creating new node: t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
Creating new node: t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
Creating new node: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
Creating new node: t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
Creating new node: t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
Creating new node: t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
Creating new node: t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
Creating new node: t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
Creating new node: t27: i64,ch = load<(dereferenceable load (s64) from %ir.f)> t21, FrameIndex:i64<6>, undef:i64
Creating new node: t28: i64,ch = load<(dereferenceable load (s64) from %ir.g)> t21, FrameIndex:i64<7>, undef:i64
Creating new node: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t27:1, t28:1
error: <unknown>:0:0: in function main i32 (): too many args to t29: i64 = GlobalAddress<ptr @add> 0

Creating constant: t31: i64 = TargetConstant<16>
Creating constant: t32: i64 = TargetConstant<0>
Creating new node: t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>
Creating new node: t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
Creating new node: t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
Creating new node: t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
Creating new node: t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
Creating new node: t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
Creating new node: t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
Creating new node: t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1
Creating new node: t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
Creating new node: t49: i32 = truncate t48
Creating new node: t51: ch = store<(store (s32) into %ir.cc)> t48:1, t49, FrameIndex:i64<8>, undef:i64
Creating new node: t52: i32,ch = load<(dereferenceable load (s32) from %ir.cc)> t51, FrameIndex:i64<8>, undef:i64
Creating new node: t53: i64 = any_extend t52
Creating new node: t54: ch,glue = CopyToReg t51, Register:i64 $r0, t53
Creating new node: t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1
Initial selection DAG: %bb.0 'main:entry'
SelectionDAG has 56 nodes:
  t3: i64 = Constant<0>
                  t0: ch = EntryToken
                t5: ch = store<(store (s32) into %ir.retval)> t0, Constant:i32<0>, FrameIndex:i64<0>, undef:i64
              t8: ch = store<(store (s64) into %ir.a)> t5, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
            t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
          t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
        t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
      t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
    t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
  t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
  t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
  t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
  t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
  t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
  t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
  t29: i64 = GlobalAddress<ptr @add> 0
        t27: i64,ch = load<(dereferenceable load (s64) from %ir.f)> t21, FrameIndex:i64<6>, undef:i64
        t28: i64,ch = load<(dereferenceable load (s64) from %ir.g)> t21, FrameIndex:i64<7>, undef:i64
      t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t27:1, t28:1
    t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>
  t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
  t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
  t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
  t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
  t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
  t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
  t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1
  t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
    t49: i32 = truncate t48
  t51: ch = store<(store (s32) into %ir.cc)> t48:1, t49, FrameIndex:i64<8>, undef:i64
      t52: i32,ch = load<(dereferenceable load (s32) from %ir.cc)> t51, FrameIndex:i64<8>, undef:i64
    t53: i64 = any_extend t52
  t54: ch,glue = CopyToReg t51, Register:i64 $r0, t53
  t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1



Combining: t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1

Combining: t54: ch,glue = CopyToReg t51, Register:i64 $r0, t53

Combining: t53: i64 = any_extend t52
Creating new node: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t51, FrameIndex:i64<8>, undef:i64

Replacing.1 t53: i64 = any_extend t52

With: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t51, FrameIndex:i64<8>, undef:i64
 and 0 other values

Combining: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t51, FrameIndex:i64<8>, undef:i64

Combining: t54: ch,glue = CopyToReg t51, Register:i64 $r0, t56

Combining: t51: ch = store<(store (s32) into %ir.cc)> t48:1, t49, FrameIndex:i64<8>, undef:i64
Creating new node: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
 ... into: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64

Combining: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64

Combining: t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56

Combining: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64

Combining: t50: i64 = FrameIndex<8>

Combining: t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1

Combining: t47: i64 = Register $r0

Combining: t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1

Combining: t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1

Combining: t44: i64 = TargetGlobalAddress<ptr @add> 0

Combining: t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1

Combining: t42: i64 = Register $r5

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1

Combining: t40: i64 = Register $r4

Combining: t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1

Combining: t38: i64 = Register $r3

Combining: t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1

Combining: t36: i64 = Register $r2

Combining: t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22

Combining: t34: i64 = Register $r1

Combining: t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>

Combining: t32: i64 = TargetConstant<0>

Combining: t31: i64 = TargetConstant<16>

Combining: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t27:1, t28:1

Combining: t28: i64,ch = load<(dereferenceable load (s64) from %ir.g)> t21, FrameIndex:i64<7>, undef:i64

Replacing.6 t28: i64,ch = load<(dereferenceable load (s64) from %ir.g)> t21, FrameIndex:i64<7>, undef:i64

With chain: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64


Combining: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t27:1, t21

Combining: t27: i64,ch = load<(dereferenceable load (s64) from %ir.f)> t21, FrameIndex:i64<6>, undef:i64

Replacing.6 t27: i64,ch = load<(dereferenceable load (s64) from %ir.f)> t21, FrameIndex:i64<6>, undef:i64

With chain: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64


Combining: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21

Combining: t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64

Combining: t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64

Combining: t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64

Combining: t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64

Combining: t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64

Combining: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64

Combining: t20: i64 = FrameIndex<7>

Combining: t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64

Combining: t18: i64 = FrameIndex<6>

Combining: t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64

Combining: t16: i64 = FrameIndex<5>

Combining: t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64

Combining: t14: i64 = FrameIndex<4>

Combining: t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64

Combining: t12: i64 = FrameIndex<3>

Combining: t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64

Combining: t10: i64 = FrameIndex<2>

Combining: t9: i64 = Constant<10>

Combining: t8: ch = store<(store (s64) into %ir.a)> t5, Constant:i64<9>, FrameIndex:i64<1>, undef:i64

Combining: t7: i64 = FrameIndex<1>

Combining: t6: i64 = Constant<9>

Combining: t5: ch = store<(store (s32) into %ir.retval)> t0, Constant:i32<0>, FrameIndex:i64<0>, undef:i64

Combining: t4: i64 = undef

Combining: t2: i64 = FrameIndex<0>

Combining: t1: i32 = Constant<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'main:entry'
SelectionDAG has 50 nodes:
                  t0: ch = EntryToken
                t5: ch = store<(store (s32) into %ir.retval)> t0, Constant:i32<0>, FrameIndex:i64<0>, undef:i64
              t8: ch = store<(store (s64) into %ir.a)> t5, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
            t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
          t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
        t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
      t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
    t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
  t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
  t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
  t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
  t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
  t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
  t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
      t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21
    t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>
  t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
  t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
  t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
  t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
  t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
  t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
  t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1
  t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
    t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64
  t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56
  t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
  t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1


Legalizing node: t50: i64 = FrameIndex<8>
Analyzing result type: i64
Legal result type
Legally typed node: t50: i64 = FrameIndex<8>

Legalizing node: t47: i64 = Register $r0
Ignoring node results
Legally typed node: t47: i64 = Register $r0

Legalizing node: t44: i64 = TargetGlobalAddress<ptr @add> 0
Analyzing result type: i64
Legal result type
Legally typed node: t44: i64 = TargetGlobalAddress<ptr @add> 0

Legalizing node: t42: i64 = Register $r5
Ignoring node results
Legally typed node: t42: i64 = Register $r5

Legalizing node: t40: i64 = Register $r4
Ignoring node results
Legally typed node: t40: i64 = Register $r4

Legalizing node: t38: i64 = Register $r3
Ignoring node results
Legally typed node: t38: i64 = Register $r3

Legalizing node: t36: i64 = Register $r2
Ignoring node results
Legally typed node: t36: i64 = Register $r2

Legalizing node: t34: i64 = Register $r1
Ignoring node results
Legally typed node: t34: i64 = Register $r1

Legalizing node: t32: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t32: i64 = TargetConstant<0>

Legalizing node: t31: i64 = TargetConstant<16>
Ignoring node results
Legally typed node: t31: i64 = TargetConstant<16>

Legalizing node: t20: i64 = FrameIndex<7>
Analyzing result type: i64
Legal result type
Legally typed node: t20: i64 = FrameIndex<7>

Legalizing node: t18: i64 = FrameIndex<6>
Analyzing result type: i64
Legal result type
Legally typed node: t18: i64 = FrameIndex<6>

Legalizing node: t16: i64 = FrameIndex<5>
Analyzing result type: i64
Legal result type
Legally typed node: t16: i64 = FrameIndex<5>

Legalizing node: t14: i64 = FrameIndex<4>
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = FrameIndex<4>

Legalizing node: t12: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t12: i64 = FrameIndex<3>

Legalizing node: t10: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t10: i64 = FrameIndex<2>

Legalizing node: t9: i64 = Constant<10>
Analyzing result type: i64
Legal result type
Legally typed node: t9: i64 = Constant<10>

Legalizing node: t7: i64 = FrameIndex<1>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = FrameIndex<1>

Legalizing node: t6: i64 = Constant<9>
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = Constant<9>

Legalizing node: t4: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t4: i64 = undef

Legalizing node: t2: i64 = FrameIndex<0>
Analyzing result type: i64
Legal result type
Legally typed node: t2: i64 = FrameIndex<0>

Legalizing node: t1: i32 = Constant<0>
Analyzing result type: i32
Promote integer result: t1: i32 = Constant<0>

Creating constant: t58: i64 = Constant<0>
Legalizing node: t58: i64 = Constant<0>
Analyzing result type: i64
Legal result type
Legally typed node: t58: i64 = Constant<0>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t5: ch = store<(store (s32) into %ir.retval)> t0, Constant:i32<0>, FrameIndex:i64<0>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<0>
Promote integer operand: t5: ch = store<(store (s32) into %ir.retval)> t0, Constant:i32<0>, FrameIndex:i64<0>, undef:i64

Creating new node: t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64
Replacing: t5: ch = store<(store (s32) into %ir.retval)> t0, Constant:i32<0>, FrameIndex:i64<0>, undef:i64
     with: t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64
Legalizing node: t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t58: i64 = Constant<0>
Legal operand
Analyzing operand: t2: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64

Legalizing node: t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t6: i64 = Constant<9>
Legal operand
Analyzing operand: t7: i64 = FrameIndex<1>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64

Legalizing node: t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t9: i64 = Constant<10>
Legal operand
Analyzing operand: t10: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64

Legalizing node: t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t6: i64 = Constant<9>
Legal operand
Analyzing operand: t12: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64

Legalizing node: t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t9: i64 = Constant<10>
Legal operand
Analyzing operand: t14: i64 = FrameIndex<4>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64

Legalizing node: t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
Legal operand
Analyzing operand: t6: i64 = Constant<9>
Legal operand
Analyzing operand: t16: i64 = FrameIndex<5>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64

Legalizing node: t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
Legal operand
Analyzing operand: t9: i64 = Constant<10>
Legal operand
Analyzing operand: t18: i64 = FrameIndex<6>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64

Legalizing node: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
Legal operand
Analyzing operand: t6: i64 = Constant<9>
Legal operand
Analyzing operand: t20: i64 = FrameIndex<7>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64

Legalizing node: t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
Legal operand
Analyzing operand: t7: i64 = FrameIndex<1>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64

Legalizing node: t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
Legal operand
Analyzing operand: t10: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64

Legalizing node: t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
Legal operand
Analyzing operand: t12: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64

Legalizing node: t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
Legal operand
Analyzing operand: t14: i64 = FrameIndex<4>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64

Legalizing node: t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
Legal operand
Analyzing operand: t16: i64 = FrameIndex<5>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64

Legalizing node: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21
Analyzing result type: ch
Legal result type
Analyzing operand: t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
Legal operand
Analyzing operand: t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
Legal operand
Analyzing operand: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
Legal operand
Analyzing operand: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
Legal operand
Legally typed node: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21

Legalizing node: t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21
Legal operand
Legally typed node: t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>

Legalizing node: t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
Legal operand
Legally typed node: t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22

Legalizing node: t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
Legal operand
Analyzing operand: t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
Legal operand
Legally typed node: t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1

Legalizing node: t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
Legal operand
Analyzing operand: t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
Legal operand
Legally typed node: t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1

Legalizing node: t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
Legal operand
Analyzing operand: t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
Legal operand
Analyzing operand: t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
Legal operand
Legally typed node: t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1

Legalizing node: t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
Legal operand
Analyzing operand: t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
Legal operand
Analyzing operand: t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
Legal operand
Legally typed node: t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1

Legalizing node: t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
Legal operand
Analyzing operand: t44: i64 = TargetGlobalAddress<ptr @add> 0
Legal operand
Analyzing operand: t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
Legal operand
Legally typed node: t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1

Legalizing node: t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
Legal operand
Analyzing operand: t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
Legal operand
Legally typed node: t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1

Legalizing node: t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1
Legal operand
Analyzing operand: t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1
Legal operand
Legally typed node: t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1

Legalizing node: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
Legal operand
Analyzing operand: t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
Legal operand
Analyzing operand: t50: i64 = FrameIndex<8>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64

Legalizing node: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
Legal operand
Analyzing operand: t50: i64 = FrameIndex<8>
Legal operand
Analyzing operand: t4: i64 = undef
Legal operand
Legally typed node: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64

Legalizing node: t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
Legal operand
Analyzing operand: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64
Legal operand
Legally typed node: t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56

Legalizing node: t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1
Analyzing result type: ch
Legal result type
Analyzing operand: t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56
Legal operand
Analyzing operand: t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56
Legal operand
Legally typed node: t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1

Legalizing node: t65535: ch = handlenode t55
Analyzing result type: ch
Legal result type
Analyzing operand: t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1
Legal operand
Legally typed node: t65535: ch = handlenode t55

Type-legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 50 nodes:
                  t0: ch = EntryToken
                t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64
              t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
            t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
          t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
        t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
      t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
    t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
  t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
  t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
  t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
  t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
  t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
  t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
      t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21
    t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>
  t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
  t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
  t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
  t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
  t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
  t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
  t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1
  t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
    t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64
  t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56
  t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
  t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1



Combining: t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64

Combining: t58: i64 = Constant<0>

Combining: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64

Combining: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64

Combining: t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1

Combining: t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56

Combining: t50: i64 = FrameIndex<8>

Combining: t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1

Combining: t47: i64 = Register $r0

Combining: t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1

Combining: t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1

Combining: t44: i64 = TargetGlobalAddress<ptr @add> 0

Combining: t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1

Combining: t42: i64 = Register $r5

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1

Combining: t40: i64 = Register $r4

Combining: t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1

Combining: t38: i64 = Register $r3

Combining: t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1

Combining: t36: i64 = Register $r2

Combining: t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22

Combining: t34: i64 = Register $r1

Combining: t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>

Combining: t32: i64 = TargetConstant<0>

Combining: t31: i64 = TargetConstant<16>

Combining: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21

Combining: t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64

Combining: t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64

Combining: t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64

Combining: t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64

Combining: t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64

Combining: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64

Combining: t20: i64 = FrameIndex<7>

Combining: t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64

Combining: t18: i64 = FrameIndex<6>

Combining: t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64

Combining: t16: i64 = FrameIndex<5>

Combining: t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64

Combining: t14: i64 = FrameIndex<4>

Combining: t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64

Combining: t12: i64 = FrameIndex<3>

Combining: t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64

Combining: t10: i64 = FrameIndex<2>

Combining: t9: i64 = Constant<10>

Combining: t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64

Combining: t7: i64 = FrameIndex<1>

Combining: t6: i64 = Constant<9>

Combining: t4: i64 = undef

Combining: t2: i64 = FrameIndex<0>

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 50 nodes:
                  t0: ch = EntryToken
                t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64
              t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
            t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
          t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
        t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
      t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
    t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
  t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
  t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
  t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
  t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
  t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
  t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
      t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21
    t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>
  t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
  t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
  t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
  t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
  t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
  t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
  t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1
  t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
    t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64
  t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56
  t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
  t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1



Legalizing: t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1
Legal node: nothing to do

Legalizing: t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56
Legal node: nothing to do

Legalizing: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64
Legalizing extending load operation

Legalizing: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
Legalizing truncating store operations

Legalizing: t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
Legal node: nothing to do

Legalizing: t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1

Legalizing: t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
Legal node: nothing to do

Legalizing: t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
Legal node: nothing to do

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
Legal node: nothing to do

Legalizing: t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
Legal node: nothing to do

Legalizing: t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
Legal node: nothing to do

Legalizing: t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
Legal node: nothing to do

Legalizing: t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>

Legalizing: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21
Legal node: nothing to do

Legalizing: t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Legalizing: t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Legalizing: t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Legalizing: t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
Legalizing non-extending load operation

Legalizing: t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
Legalizing non-extending load operation

Legalizing: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64
Legalizing truncating store operations

Legalizing: t58: i64 = Constant<0>
Legal node: nothing to do

Legalizing: t50: i64 = FrameIndex<8>
Legal node: nothing to do

Legalizing: t47: i64 = Register $r0

Legalizing: t44: i64 = TargetGlobalAddress<ptr @add> 0
Legal node: nothing to do

Legalizing: t42: i64 = Register $r5

Legalizing: t40: i64 = Register $r4

Legalizing: t38: i64 = Register $r3

Legalizing: t36: i64 = Register $r2

Legalizing: t34: i64 = Register $r1

Legalizing: t32: i64 = TargetConstant<0>

Legalizing: t31: i64 = TargetConstant<16>

Legalizing: t20: i64 = FrameIndex<7>
Legal node: nothing to do

Legalizing: t18: i64 = FrameIndex<6>
Legal node: nothing to do

Legalizing: t16: i64 = FrameIndex<5>
Legal node: nothing to do

Legalizing: t14: i64 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t12: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t10: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t9: i64 = Constant<10>
Legal node: nothing to do

Legalizing: t7: i64 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t6: i64 = Constant<9>
Legal node: nothing to do

Legalizing: t4: i64 = undef
Legal node: nothing to do

Legalizing: t2: i64 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 50 nodes:
                  t0: ch = EntryToken
                t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64
              t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
            t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
          t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
        t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
      t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
    t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
  t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
  t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
  t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
  t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
  t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
  t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
      t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21
    t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>
  t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
  t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
  t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
  t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
  t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
  t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
  t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1
  t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
  t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
    t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64
  t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56
  t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1



Legalizing: t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1
Legal node: nothing to do

Combining: t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1

Legalizing: t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56
Legal node: nothing to do

Combining: t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56

Legalizing: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64
Legalizing extending load operation

Combining: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64

Legalizing: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
Legalizing truncating store operations

Combining: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64

Legalizing: t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
Legal node: nothing to do

Combining: t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1

Legalizing: t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1

Combining: t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1

Legalizing: t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
Legal node: nothing to do

Combining: t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1

Legalizing: t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
Legal node: nothing to do

Combining: t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1

Legalizing: t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
Legal node: nothing to do

Combining: t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1

Legalizing: t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
Legal node: nothing to do

Combining: t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1

Legalizing: t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
Legal node: nothing to do

Combining: t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1

Legalizing: t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
Legal node: nothing to do

Combining: t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22

Legalizing: t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>

Combining: t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>

Legalizing: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21
Legal node: nothing to do

Combining: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21

Legalizing: t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Combining: t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64

Legalizing: t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Combining: t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64

Legalizing: t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Combining: t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64

Legalizing: t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
Legalizing non-extending load operation

Combining: t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64

Legalizing: t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
Legalizing non-extending load operation

Combining: t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64

Legalizing: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64

Legalizing: t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64

Legalizing: t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64

Legalizing: t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64

Legalizing: t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64

Legalizing: t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64

Legalizing: t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64

Legalizing: t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64
Legalizing truncating store operations

Combining: t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64

Legalizing: t58: i64 = Constant<0>
Legal node: nothing to do

Combining: t58: i64 = Constant<0>

Legalizing: t50: i64 = FrameIndex<8>
Legal node: nothing to do

Combining: t50: i64 = FrameIndex<8>

Legalizing: t47: i64 = Register $r0

Combining: t47: i64 = Register $r0

Legalizing: t44: i64 = TargetGlobalAddress<ptr @add> 0
Legal node: nothing to do

Combining: t44: i64 = TargetGlobalAddress<ptr @add> 0

Legalizing: t42: i64 = Register $r5

Combining: t42: i64 = Register $r5

Legalizing: t40: i64 = Register $r4

Combining: t40: i64 = Register $r4

Legalizing: t38: i64 = Register $r3

Combining: t38: i64 = Register $r3

Legalizing: t36: i64 = Register $r2

Combining: t36: i64 = Register $r2

Legalizing: t34: i64 = Register $r1

Combining: t34: i64 = Register $r1

Legalizing: t32: i64 = TargetConstant<0>

Combining: t32: i64 = TargetConstant<0>

Legalizing: t31: i64 = TargetConstant<16>

Combining: t31: i64 = TargetConstant<16>

Legalizing: t20: i64 = FrameIndex<7>
Legal node: nothing to do

Combining: t20: i64 = FrameIndex<7>

Legalizing: t18: i64 = FrameIndex<6>
Legal node: nothing to do

Combining: t18: i64 = FrameIndex<6>

Legalizing: t16: i64 = FrameIndex<5>
Legal node: nothing to do

Combining: t16: i64 = FrameIndex<5>

Legalizing: t14: i64 = FrameIndex<4>
Legal node: nothing to do

Combining: t14: i64 = FrameIndex<4>

Legalizing: t12: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t12: i64 = FrameIndex<3>

Legalizing: t10: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t10: i64 = FrameIndex<2>

Legalizing: t9: i64 = Constant<10>
Legal node: nothing to do

Combining: t9: i64 = Constant<10>

Legalizing: t7: i64 = FrameIndex<1>
Legal node: nothing to do

Combining: t7: i64 = FrameIndex<1>

Legalizing: t6: i64 = Constant<9>
Legal node: nothing to do

Combining: t6: i64 = Constant<9>

Legalizing: t4: i64 = undef
Legal node: nothing to do

Combining: t4: i64 = undef

Legalizing: t2: i64 = FrameIndex<0>
Legal node: nothing to do

Combining: t2: i64 = FrameIndex<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 50 nodes:
                  t0: ch = EntryToken
                t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64
              t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
            t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
          t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
        t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
      t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
    t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
  t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
  t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
  t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
  t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
  t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
  t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
      t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21
    t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>
  t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22
  t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
  t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
  t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
  t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
  t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
  t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1
  t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1
  t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
    t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64
  t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56
  t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t55: ch = BPFISD::RET_FLAG t54, Register:i64 $r0, t54:1
ISEL: Starting pattern match
  Initial Opcode index to 3467
  Morphed node: t55: ch = RET Register:i64 $r0, t54, t54:1
ISEL: Match complete!

ISEL: Starting selection on root node: t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56

ISEL: Starting selection on root node: t56: i64,ch = load<(dereferenceable load (s32) from %ir.cc), anyext from i32> t57, FrameIndex:i64<8>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Skipped scope entry (due to false predicate) at index 473, continuing at 487
  Skipped scope entry (due to false predicate) at index 492, continuing at 508
  Skipped scope entry (due to false predicate) at index 509, continuing at 525
  Morphed node: t56: i64,ch = LDW<Mem:(dereferenceable load (s32) from %ir.cc)> TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t57
ISEL: Match complete!

ISEL: Starting selection on root node: t57: ch = store<(store (s32) into %ir.cc), trunc to i32> t48:1, t48, FrameIndex:i64<8>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Morphed node: t57: ch = STW<Mem:(store (s32) into %ir.cc)> t48, TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t48:1
ISEL: Match complete!

ISEL: Starting selection on root node: t48: i64,ch,glue = CopyFromReg t46, Register:i64 $r0, t46:1

ISEL: Starting selection on root node: t46: ch,glue = callseq_end t45, TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1
ISEL: Starting pattern match
  Initial Opcode index to 2649
  Morphed node: t46: i64,ch,glue = ADJCALLSTACKUP TargetConstant:i64<16>, TargetConstant:i64<0>, t45, t45:1
ISEL: Match complete!

ISEL: Starting selection on root node: t45: ch,glue = BPFISD::CALL t43, TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43:1
ISEL: Starting pattern match
  Initial Opcode index to 3344
  OpcodeSwitch from 3350 to 3354
  Morphed node: t45: i64,ch,glue = JAL TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43, t43:1
ISEL: Match complete!

ISEL: Starting selection on root node: t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1

ISEL: Starting selection on root node: t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1

ISEL: Starting selection on root node: t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1

ISEL: Starting selection on root node: t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1

ISEL: Starting selection on root node: t35: ch,glue = CopyToReg t33, Register:i64 $r1, t22

ISEL: Starting selection on root node: t33: ch,glue = callseq_start t30, TargetConstant:i64<16>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 2624
  Morphed node: t33: i64,ch,glue = ADJCALLSTACKDOWN TargetConstant:i64<16>, TargetConstant:i64<0>, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21

ISEL: Starting selection on root node: t22: i64,ch = load<(dereferenceable load (s64) from %ir.a)> t21, FrameIndex:i64<1>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Morphed node: t22: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t23: i64,ch = load<(dereferenceable load (s64) from %ir.b)> t21, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Morphed node: t23: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t24: i64,ch = load<(dereferenceable load (s64) from %ir.c)> t21, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Morphed node: t24: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t25: i64,ch = load<(dereferenceable load (s64) from %ir.d)> t21, FrameIndex:i64<4>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Morphed node: t25: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t26: i64,ch = load<(dereferenceable load (s64) from %ir.e)> t21, FrameIndex:i64<5>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 404
  TypeSwitch[i64] from 411 to 415
  Skipped scope entry (due to false predicate) at index 417, continuing at 472
  Morphed node: t26: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t21
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = store<(store (s64) into %ir.g)> t19, Constant:i64<9>, FrameIndex:i64<7>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t21: ch = STD<Mem:(store (s64) into %ir.g)> Constant:i64<9>, TargetFrameIndex:i64<7>, TargetConstant:i64<0>, t19
ISEL: Match complete!

ISEL: Starting selection on root node: t19: ch = store<(store (s64) into %ir.f)> t17, Constant:i64<10>, FrameIndex:i64<6>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t19: ch = STD<Mem:(store (s64) into %ir.f)> Constant:i64<10>, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t17
ISEL: Match complete!

ISEL: Starting selection on root node: t17: ch = store<(store (s64) into %ir.e)> t15, Constant:i64<9>, FrameIndex:i64<5>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t17: ch = STD<Mem:(store (s64) into %ir.e)> Constant:i64<9>, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t15
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch = store<(store (s64) into %ir.d)> t13, Constant:i64<10>, FrameIndex:i64<4>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t15: ch = STD<Mem:(store (s64) into %ir.d)> Constant:i64<10>, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = store<(store (s64) into %ir.c)> t11, Constant:i64<9>, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t13: ch = STD<Mem:(store (s64) into %ir.c)> Constant:i64<9>, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t11
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = store<(store (s64) into %ir.b)> t8, Constant:i64<10>, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t11: ch = STD<Mem:(store (s64) into %ir.b)> Constant:i64<10>, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t8
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch = store<(store (s64) into %ir.a)> t59, Constant:i64<9>, FrameIndex:i64<1>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Skipped scope entry (due to false predicate) at index 173, continuing at 228
  Morphed node: t8: ch = STD<Mem:(store (s64) into %ir.a)> Constant:i64<9>, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t59
ISEL: Match complete!

ISEL: Starting selection on root node: t59: ch = store<(store (s32) into %ir.retval), trunc to i32> t0, Constant:i64<0>, FrameIndex:i64<0>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 158
  Morphed node: t59: ch = STW<Mem:(store (s32) into %ir.retval)> Constant:i64<0>, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t58: i64 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 3405
  TypeSwitch[i64] from 3406 to 3409
  Morphed node: t58: i64 = MOV_ri TargetConstant:i64<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t47: i64 = Register $r0

ISEL: Starting selection on root node: t44: i64 = TargetGlobalAddress<ptr @add> 0

ISEL: Starting selection on root node: t42: i64 = Register $r5

ISEL: Starting selection on root node: t40: i64 = Register $r4

ISEL: Starting selection on root node: t38: i64 = Register $r3

ISEL: Starting selection on root node: t36: i64 = Register $r2

ISEL: Starting selection on root node: t34: i64 = Register $r1

ISEL: Starting selection on root node: t32: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t31: i64 = TargetConstant<16>

ISEL: Starting selection on root node: t9: i64 = Constant<10>
ISEL: Starting pattern match
  Initial Opcode index to 3405
  TypeSwitch[i64] from 3406 to 3409
Creating constant: t69: i64 = TargetConstant<10>
  Morphed node: t9: i64 = MOV_ri TargetConstant:i64<10>
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i64 = Constant<9>
ISEL: Starting pattern match
  Initial Opcode index to 3405
  TypeSwitch[i64] from 3406 to 3409
Creating constant: t70: i64 = TargetConstant<9>
  Morphed node: t6: i64 = MOV_ri TargetConstant:i64<9>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'main:entry'
SelectionDAG has 51 nodes:
  t6: i64 = MOV_ri TargetConstant:i64<9>
  t9: i64 = MOV_ri TargetConstant:i64<10>
                  t58: i64 = MOV_ri TargetConstant:i64<0>
                  t0: ch = EntryToken
                t59: ch = STW<Mem:(store (s32) into %ir.retval)> t58, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0
              t8: ch = STD<Mem:(store (s64) into %ir.a)> t6, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t59
            t11: ch = STD<Mem:(store (s64) into %ir.b)> t9, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t8
          t13: ch = STD<Mem:(store (s64) into %ir.c)> t6, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t11
        t15: ch = STD<Mem:(store (s64) into %ir.d)> t9, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t13
      t17: ch = STD<Mem:(store (s64) into %ir.e)> t6, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t15
    t19: ch = STD<Mem:(store (s64) into %ir.f)> t9, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t17
  t21: ch = STD<Mem:(store (s64) into %ir.g)> t6, TargetFrameIndex:i64<7>, TargetConstant:i64<0>, t19
  t26: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t21
  t25: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t21
  t24: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t21
  t23: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t21
  t22: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t21
      t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21
    t33: i64,ch,glue = ADJCALLSTACKDOWN TargetConstant:i64<16>, TargetConstant:i64<0>, t30
  t35: ch,glue = CopyToReg t33:1, Register:i64 $r1, t22
  t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1
  t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1
  t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1
  t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1
  t45: i64,ch,glue = JAL TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43, t43:1
  t46: i64,ch,glue = ADJCALLSTACKUP TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1, t45:2
  t48: i64,ch,glue = CopyFromReg t46:1, Register:i64 $r0, t46:2
  t57: ch = STW<Mem:(store (s32) into %ir.cc)> t48, TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t48:1
    t56: i64,ch = LDW<Mem:(dereferenceable load (s32) from %ir.cc)> TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t57
  t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56
  t55: ch = RET Register:i64 $r0, t54, t54:1


********** List Scheduling %bb.0 'entry' **********
SU(0): t55: ch = RET Register:i64 $r0, t54, t54:1

    t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 14
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Barrier
    SU(1): Data Latency=1
SU(1): t56: i64,ch = LDW<Mem:(dereferenceable load (s32) from %ir.cc)> TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t57

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 13
  Height             : 1
  Predecessors:
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Data Latency=1
SU(2): t57: ch = STW<Mem:(store (s32) into %ir.cc)> t48, TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t48:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 12
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
    SU(1): Ord  Latency=1 Barrier
SU(3): t48: i64,ch,glue = CopyFromReg t46:1, Register:i64 $r0, t46:2

    t35: ch,glue = CopyToReg t33:1, Register:i64 $r1, t22

    t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1

    t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1

    t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1

    t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1

    t45: i64,ch,glue = JAL TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43, t43:1

    t46: i64,ch,glue = ADJCALLSTACKUP TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1, t45:2

  # preds left       : 6
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 11
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
    SU(16): Data Latency=1
    SU(17): Data Latency=1
    SU(18): Data Latency=1
    SU(20): Ord  Latency=1 Barrier
    SU(19): Data Latency=1
  Successors:
    SU(2): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
SU(4): t26: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t21

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 9
  Height             : 5
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(3): Data Latency=1
    SU(21): Ord  Latency=1 Barrier
SU(5): t21: ch = STD<Mem:(store (s64) into %ir.g)> t6, TargetFrameIndex:i64<7>, TargetConstant:i64<0>, t19

  # preds left       : 2
  # succs left       : 6
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 6
  Predecessors:
    SU(15): Data Latency=1
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(16): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(19): Ord  Latency=1 Barrier
    SU(21): Ord  Latency=1 Barrier
SU(6): t19: ch = STD<Mem:(store (s64) into %ir.f)> t9, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t17

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 7
  Predecessors:
    SU(14): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(7): t17: ch = STD<Mem:(store (s64) into %ir.e)> t6, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t15

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 8
  Predecessors:
    SU(15): Data Latency=1
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(6): Ord  Latency=1 Barrier
SU(8): t15: ch = STD<Mem:(store (s64) into %ir.d)> t9, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t13

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 9
  Predecessors:
    SU(14): Data Latency=1
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(7): Ord  Latency=1 Barrier
SU(9): t13: ch = STD<Mem:(store (s64) into %ir.c)> t6, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t11

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 10
  Predecessors:
    SU(15): Data Latency=1
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(8): Ord  Latency=1 Barrier
SU(10): t11: ch = STD<Mem:(store (s64) into %ir.b)> t9, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t8

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 11
  Predecessors:
    SU(14): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
  Successors:
    SU(9): Ord  Latency=1 Barrier
SU(11): t8: ch = STD<Mem:(store (s64) into %ir.a)> t6, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t59

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 12
  Predecessors:
    SU(15): Data Latency=1
    SU(12): Ord  Latency=1 Barrier
  Successors:
    SU(10): Ord  Latency=1 Barrier
SU(12): t59: ch = STW<Mem:(store (s32) into %ir.retval)> t58, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 13
  Predecessors:
    SU(13): Data Latency=1
  Successors:
    SU(11): Ord  Latency=1 Barrier
SU(13): t58: i64 = MOV_ri TargetConstant:i64<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 14
  Successors:
    SU(12): Data Latency=1
SU(14): t9: i64 = MOV_ri TargetConstant:i64<10>

  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 12
  Successors:
    SU(6): Data Latency=1
    SU(8): Data Latency=1
    SU(10): Data Latency=1
SU(15): t6: i64 = MOV_ri TargetConstant:i64<9>

  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 13
  Successors:
    SU(5): Data Latency=1
    SU(7): Data Latency=1
    SU(9): Data Latency=1
    SU(11): Data Latency=1
SU(16): t25: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t21

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 9
  Height             : 5
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(3): Data Latency=1
    SU(21): Ord  Latency=1 Barrier
SU(17): t24: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t21

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 9
  Height             : 5
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(3): Data Latency=1
    SU(21): Ord  Latency=1 Barrier
SU(18): t23: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t21

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 9
  Height             : 5
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(3): Data Latency=1
    SU(21): Ord  Latency=1 Barrier
SU(19): t22: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t21

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 9
  Height             : 5
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(3): Data Latency=1
    SU(21): Ord  Latency=1 Barrier
SU(20): t33: i64,ch,glue = ADJCALLSTACKDOWN TargetConstant:i64<16>, TargetConstant:i64<0>, t30

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 10
  Height             : 4
  Predecessors:
    SU(21): Ord  Latency=0 Barrier
  Successors:
    SU(3): Ord  Latency=1 Barrier
SU(21): t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21

  # preds left       : 6
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 10
  Height             : 4
  Predecessors:
    SU(19): Ord  Latency=1 Barrier
    SU(18): Ord  Latency=1 Barrier
    SU(17): Ord  Latency=1 Barrier
    SU(16): Ord  Latency=1 Barrier
    SU(4): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(20): Ord  Latency=0 Barrier

Examining Available:
Height 0: SU(0): t55: ch = RET Register:i64 $r0, t54, t54:1

    t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56


*** Scheduling [0]: SU(0): t55: ch = RET Register:i64 $r0, t54, t54:1

    t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56


Examining Available:
Height 1: SU(1): t56: i64,ch = LDW<Mem:(dereferenceable load (s32) from %ir.cc)> TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t57


*** Scheduling [1]: SU(1): t56: i64,ch = LDW<Mem:(dereferenceable load (s32) from %ir.cc)> TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t57


Examining Available:
Height 2: SU(2): t57: ch = STW<Mem:(store (s32) into %ir.cc)> t48, TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t48:1


*** Scheduling [2]: SU(2): t57: ch = STW<Mem:(store (s32) into %ir.cc)> t48, TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t48:1


Examining Available:
Height 3: SU(3): t48: i64,ch,glue = CopyFromReg t46:1, Register:i64 $r0, t46:2

    t35: ch,glue = CopyToReg t33:1, Register:i64 $r1, t22

    t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1

    t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1

    t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1

    t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1

    t45: i64,ch,glue = JAL TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43, t43:1

    t46: i64,ch,glue = ADJCALLSTACKUP TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1, t45:2


*** Scheduling [3]: SU(3): t48: i64,ch,glue = CopyFromReg t46:1, Register:i64 $r0, t46:2

    t35: ch,glue = CopyToReg t33:1, Register:i64 $r1, t22

    t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1

    t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1

    t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1

    t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1

    t45: i64,ch,glue = JAL TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43, t43:1

    t46: i64,ch,glue = ADJCALLSTACKUP TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1, t45:2


Examining Available:
Height 4: SU(20): t33: i64,ch,glue = ADJCALLSTACKDOWN TargetConstant:i64<16>, TargetConstant:i64<0>, t30


*** Scheduling [4]: SU(20): t33: i64,ch,glue = ADJCALLSTACKDOWN TargetConstant:i64<16>, TargetConstant:i64<0>, t30


Examining Available:
Height 4: SU(21): t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21


*** Scheduling [5]: SU(21): t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21


Examining Available:
Height 6: SU(4): t26: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t21

Height 6: SU(16): t25: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t21

Height 6: SU(17): t24: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t21

Height 6: SU(18): t23: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t21

Height 6: SU(19): t22: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t21


*** Scheduling [6]: SU(4): t26: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t21


Examining Available:
Height 6: SU(16): t25: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t21

Height 6: SU(17): t24: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t21

Height 6: SU(18): t23: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t21

Height 6: SU(19): t22: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t21


*** Scheduling [7]: SU(16): t25: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t21


Examining Available:
Height 6: SU(17): t24: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t21

Height 6: SU(18): t23: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t21

Height 6: SU(19): t22: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t21


*** Scheduling [8]: SU(17): t24: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t21


Examining Available:
Height 6: SU(18): t23: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t21

Height 6: SU(19): t22: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t21


*** Scheduling [9]: SU(18): t23: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t21


Examining Available:
Height 6: SU(19): t22: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t21


*** Scheduling [10]: SU(19): t22: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t21


Examining Available:
Height 11: SU(5): t21: ch = STD<Mem:(store (s64) into %ir.g)> t6, TargetFrameIndex:i64<7>, TargetConstant:i64<0>, t19


*** Scheduling [11]: SU(5): t21: ch = STD<Mem:(store (s64) into %ir.g)> t6, TargetFrameIndex:i64<7>, TargetConstant:i64<0>, t19


Examining Available:
Height 12: SU(6): t19: ch = STD<Mem:(store (s64) into %ir.f)> t9, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t17


*** Scheduling [12]: SU(6): t19: ch = STD<Mem:(store (s64) into %ir.f)> t9, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t17


Examining Available:
Height 13: SU(7): t17: ch = STD<Mem:(store (s64) into %ir.e)> t6, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t15


*** Scheduling [13]: SU(7): t17: ch = STD<Mem:(store (s64) into %ir.e)> t6, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t15


Examining Available:
Height 14: SU(8): t15: ch = STD<Mem:(store (s64) into %ir.d)> t9, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t13


*** Scheduling [14]: SU(8): t15: ch = STD<Mem:(store (s64) into %ir.d)> t9, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t13


Examining Available:
Height 15: SU(9): t13: ch = STD<Mem:(store (s64) into %ir.c)> t6, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t11


*** Scheduling [15]: SU(9): t13: ch = STD<Mem:(store (s64) into %ir.c)> t6, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t11


Examining Available:
Height 16: SU(10): t11: ch = STD<Mem:(store (s64) into %ir.b)> t9, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t8


*** Scheduling [16]: SU(10): t11: ch = STD<Mem:(store (s64) into %ir.b)> t9, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t8


Examining Available:
Height 17: SU(14): t9: i64 = MOV_ri TargetConstant:i64<10>

Height 17: SU(11): t8: ch = STD<Mem:(store (s64) into %ir.a)> t6, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t59


*** Scheduling [17]: SU(14): t9: i64 = MOV_ri TargetConstant:i64<10>


Examining Available:
Height 17: SU(11): t8: ch = STD<Mem:(store (s64) into %ir.a)> t6, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t59


*** Scheduling [18]: SU(11): t8: ch = STD<Mem:(store (s64) into %ir.a)> t6, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t59


Examining Available:
Height 19: SU(15): t6: i64 = MOV_ri TargetConstant:i64<9>

Height 19: SU(12): t59: ch = STW<Mem:(store (s32) into %ir.retval)> t58, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0


*** Scheduling [19]: SU(15): t6: i64 = MOV_ri TargetConstant:i64<9>


Examining Available:
Height 19: SU(12): t59: ch = STW<Mem:(store (s32) into %ir.retval)> t58, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0


*** Scheduling [20]: SU(12): t59: ch = STW<Mem:(store (s32) into %ir.retval)> t58, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0


Examining Available:
Height 21: SU(13): t58: i64 = MOV_ri TargetConstant:i64<0>


*** Scheduling [21]: SU(13): t58: i64 = MOV_ri TargetConstant:i64<0>

*** Final schedule ***
SU(13): t58: i64 = MOV_ri TargetConstant:i64<0>

SU(12): t59: ch = STW<Mem:(store (s32) into %ir.retval)> t58, TargetFrameIndex:i64<0>, TargetConstant:i64<0>, t0

SU(15): t6: i64 = MOV_ri TargetConstant:i64<9>

SU(11): t8: ch = STD<Mem:(store (s64) into %ir.a)> t6, TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t59

SU(14): t9: i64 = MOV_ri TargetConstant:i64<10>

SU(10): t11: ch = STD<Mem:(store (s64) into %ir.b)> t9, TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t8

SU(9): t13: ch = STD<Mem:(store (s64) into %ir.c)> t6, TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t11

SU(8): t15: ch = STD<Mem:(store (s64) into %ir.d)> t9, TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t13

SU(7): t17: ch = STD<Mem:(store (s64) into %ir.e)> t6, TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t15

SU(6): t19: ch = STD<Mem:(store (s64) into %ir.f)> t9, TargetFrameIndex:i64<6>, TargetConstant:i64<0>, t17

SU(5): t21: ch = STD<Mem:(store (s64) into %ir.g)> t6, TargetFrameIndex:i64<7>, TargetConstant:i64<0>, t19

SU(19): t22: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.a)> TargetFrameIndex:i64<1>, TargetConstant:i64<0>, t21

SU(18): t23: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.b)> TargetFrameIndex:i64<2>, TargetConstant:i64<0>, t21

SU(17): t24: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.c)> TargetFrameIndex:i64<3>, TargetConstant:i64<0>, t21

SU(16): t25: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.d)> TargetFrameIndex:i64<4>, TargetConstant:i64<0>, t21

SU(4): t26: i64,ch = LDD<Mem:(dereferenceable load (s64) from %ir.e)> TargetFrameIndex:i64<5>, TargetConstant:i64<0>, t21

SU(21): t30: ch = TokenFactor t22:1, t23:1, t24:1, t25:1, t26:1, t21, t21

SU(20): t33: i64,ch,glue = ADJCALLSTACKDOWN TargetConstant:i64<16>, TargetConstant:i64<0>, t30

SU(3): t48: i64,ch,glue = CopyFromReg t46:1, Register:i64 $r0, t46:2

    t35: ch,glue = CopyToReg t33:1, Register:i64 $r1, t22

    t37: ch,glue = CopyToReg t35, Register:i64 $r2, t23, t35:1

    t39: ch,glue = CopyToReg t37, Register:i64 $r3, t24, t37:1

    t41: ch,glue = CopyToReg t39, Register:i64 $r4, t25, t39:1

    t43: ch,glue = CopyToReg t41, Register:i64 $r5, t26, t41:1

    t45: i64,ch,glue = JAL TargetGlobalAddress:i64<ptr @add> 0, Register:i64 $r1, Register:i64 $r2, Register:i64 $r3, Register:i64 $r4, Register:i64 $r5, t43, t43:1

    t46: i64,ch,glue = ADJCALLSTACKUP TargetConstant:i64<16>, TargetConstant:i64<0>, t45:1, t45:2

SU(2): t57: ch = STW<Mem:(store (s32) into %ir.cc)> t48, TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t48:1

SU(1): t56: i64,ch = LDW<Mem:(dereferenceable load (s32) from %ir.cc)> TargetFrameIndex:i64<8>, TargetConstant:i64<0>, t57

SU(0): t55: ch = RET Register:i64 $r0, t54, t54:1

    t54: ch,glue = CopyToReg t57, Register:i64 $r0, t56


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=8, align=8, at location [SP]
  fi#2: size=8, align=8, at location [SP]
  fi#3: size=8, align=8, at location [SP]
  fi#4: size=8, align=8, at location [SP]
  fi#5: size=8, align=8, at location [SP]
  fi#6: size=8, align=8, at location [SP]
  fi#7: size=8, align=8, at location [SP]
  fi#8: size=4, align=4, at location [SP]

bb.0.entry:
  %0:gpr = MOV_ri 0
  STW killed %0:gpr, %stack.0.retval, 0 :: (store (s32) into %ir.retval)
  %1:gpr = MOV_ri 9
  STD %1:gpr, %stack.1.a, 0 :: (store (s64) into %ir.a)
  %2:gpr = MOV_ri 10
  STD %2:gpr, %stack.2.b, 0 :: (store (s64) into %ir.b)
  STD %1:gpr, %stack.3.c, 0 :: (store (s64) into %ir.c)
  STD %2:gpr, %stack.4.d, 0 :: (store (s64) into %ir.d)
  STD %1:gpr, %stack.5.e, 0 :: (store (s64) into %ir.e)
  STD %2:gpr, %stack.6.f, 0 :: (store (s64) into %ir.f)
  STD %1:gpr, %stack.7.g, 0 :: (store (s64) into %ir.g)
  %3:gpr = LDD %stack.1.a, 0 :: (dereferenceable load (s64) from %ir.a)
  %4:gpr = LDD %stack.2.b, 0 :: (dereferenceable load (s64) from %ir.b)
  %5:gpr = LDD %stack.3.c, 0 :: (dereferenceable load (s64) from %ir.c)
  %6:gpr = LDD %stack.4.d, 0 :: (dereferenceable load (s64) from %ir.d)
  %7:gpr = LDD %stack.5.e, 0 :: (dereferenceable load (s64) from %ir.e)
  ADJCALLSTACKDOWN 16, 0, implicit-def dead $r11, implicit $r11
  $r1 = COPY %3:gpr
  $r2 = COPY %4:gpr
  $r3 = COPY %5:gpr
  $r4 = COPY %6:gpr
  $r5 = COPY %7:gpr
  JAL @add, implicit-def $r0, implicit-def dead $r1, implicit-def dead $r2, implicit-def dead $r3, implicit-def dead $r4, implicit-def dead $r5, implicit $r11, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5
  ADJCALLSTACKUP 16, 0, implicit-def dead $r11, implicit $r11
  %8:gpr = COPY $r0
  STW %8:gpr, %stack.8.cc, 0 :: (store (s32) into %ir.cc)
  %9:gpr = LDW %stack.8.cc, 0 :: (dereferenceable load (s32) from %ir.cc)
  $r0 = COPY %9:gpr
  RET implicit $r0

# End machine code for function main.


Restoring optimization level for Function main
	Before: -O0 ; After: -O2
Skipping pass 'Two-Address instruction pass' on function main
********** REWRITING TWO-ADDR INSTRS **********
********** Function: main
********** FAST REGISTER ALLOCATION **********
********** Function: main

Allocating bb.0.entry:
  %0:gpr = MOV_ri 0
  STW killed %0:gpr, %stack.0.retval, 0 :: (store (s32) into %ir.retval)
  %1:gpr = MOV_ri 9
  STD %1:gpr, %stack.1.a, 0 :: (store (s64) into %ir.a)
  %2:gpr = MOV_ri 10
  STD %2:gpr, %stack.2.b, 0 :: (store (s64) into %ir.b)
  STD %1:gpr, %stack.3.c, 0 :: (store (s64) into %ir.c)
  STD %2:gpr, %stack.4.d, 0 :: (store (s64) into %ir.d)
  STD %1:gpr, %stack.5.e, 0 :: (store (s64) into %ir.e)
  STD %2:gpr, %stack.6.f, 0 :: (store (s64) into %ir.f)
  STD %1:gpr, %stack.7.g, 0 :: (store (s64) into %ir.g)
  %3:gpr = LDD %stack.1.a, 0 :: (dereferenceable load (s64) from %ir.a)
  %4:gpr = LDD %stack.2.b, 0 :: (dereferenceable load (s64) from %ir.b)
  %5:gpr = LDD %stack.3.c, 0 :: (dereferenceable load (s64) from %ir.c)
  %6:gpr = LDD %stack.4.d, 0 :: (dereferenceable load (s64) from %ir.d)
  %7:gpr = LDD %stack.5.e, 0 :: (dereferenceable load (s64) from %ir.e)
  ADJCALLSTACKDOWN 16, 0, implicit-def dead $r11, implicit $r11
  $r1 = COPY %3:gpr
  $r2 = COPY %4:gpr
  $r3 = COPY %5:gpr
  $r4 = COPY %6:gpr
  $r5 = COPY %7:gpr
  JAL @add, implicit-def $r0, implicit-def dead $r1, implicit-def dead $r2, implicit-def dead $r3, implicit-def dead $r4, implicit-def dead $r5, implicit $r11, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5
  ADJCALLSTACKUP 16, 0, implicit-def dead $r11, implicit $r11
  %8:gpr = COPY $r0
  STW %8:gpr, %stack.8.cc, 0 :: (store (s32) into %ir.cc)
  %9:gpr = LDW %stack.8.cc, 0 :: (dereferenceable load (s32) from %ir.cc)
  $r0 = COPY %9:gpr
  RET implicit $r0

>> RET implicit $r0
Regs:
<< RET implicit killed $r0

>> $r0 = COPY %9:gpr
Regs:
Freeing $r0:
Search register for %9 in class GPR with hint $r0
	Preferred Register 1: $r0
Assigning %9 to $r0
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> %9:gpr = LDW %stack.8.cc, 0 :: (dereferenceable load (s32) from %ir.cc)
Regs:
In def of %9 use existing assignment to $r0
Freeing $r0: %9
<< $r0 = LDW %stack.8.cc, 0 :: (dereferenceable load (s32) from %ir.cc)

>> STW %8:gpr, %stack.8.cc, 0 :: (store (s32) into %ir.cc)
Regs:
Search register for %8 in class GPR with hint $noreg
	Preferred Register 0: $r0
Assigning %8 to $r0
<< STW killed $r0, %stack.8.cc, 0 :: (store (s32) into %ir.cc)

>> %8:gpr = COPY $r0
Regs:
In def of %8 use existing assignment to $r0
Freeing $r0: %8
<< $r0 = COPY killed $r0
Mark identity copy for removal

>> ADJCALLSTACKUP 16, 0, implicit-def dead $r11, implicit $r11
Regs:
<< ADJCALLSTACKUP 16, 0, implicit-def dead $r11, implicit $r11

>> JAL @add, implicit-def $r0, implicit-def dead $r1, implicit-def dead $r2, implicit-def dead $r3, implicit-def dead $r4, implicit-def dead $r5, implicit $r11, implicit $r1, implicit $r2, implicit $r3, implicit $r4, implicit $r5
Regs:
Freeing $r5:
Freeing $r4:
Freeing $r3:
Freeing $r2:
Freeing $r1:
Freeing $r0:
<< JAL @add, implicit-def $r0, implicit-def dead $r1, implicit-def dead $r2, implicit-def dead $r3, implicit-def dead $r4, implicit-def dead $r5, implicit $r11, implicit killed $r1, implicit killed $r2, implicit killed $r3, implicit killed $r4, implicit killed $r5

>> $r5 = COPY %7:gpr
Regs: W1[P] W2[P] W3[P] W4[P] W5[P]
Freeing $r5:
Search register for %7 in class GPR with hint $r5
	Preferred Register 1: $r5
Assigning %7 to $r5
<< $r5 = COPY killed $r5
Mark identity copy for removal

>> $r4 = COPY %6:gpr
Regs: W1[P] W2[P] W3[P] W4[P] W5=%7
Freeing $r4:
Search register for %6 in class GPR with hint $r4
	Preferred Register 1: $r4
Assigning %6 to $r4
<< $r4 = COPY killed $r4
Mark identity copy for removal

>> $r3 = COPY %5:gpr
Regs: W1[P] W2[P] W3[P] W4=%6 W5=%7
Freeing $r3:
Search register for %5 in class GPR with hint $r3
	Preferred Register 1: $r3
Assigning %5 to $r3
<< $r3 = COPY killed $r3
Mark identity copy for removal

>> $r2 = COPY %4:gpr
Regs: W1[P] W2[P] W3=%5 W4=%6 W5=%7
Freeing $r2:
Search register for %4 in class GPR with hint $r2
	Preferred Register 1: $r2
Assigning %4 to $r2
<< $r2 = COPY killed $r2
Mark identity copy for removal

>> $r1 = COPY %3:gpr
Regs: W1[P] W2=%4 W3=%5 W4=%6 W5=%7
Freeing $r1:
Search register for %3 in class GPR with hint $r1
	Preferred Register 1: $r1
Assigning %3 to $r1
<< $r1 = COPY killed $r1
Mark identity copy for removal

>> ADJCALLSTACKDOWN 16, 0, implicit-def dead $r11, implicit $r11
Regs: W1=%3 W2=%4 W3=%5 W4=%6 W5=%7
<< ADJCALLSTACKDOWN 16, 0, implicit-def dead $r11, implicit $r11

>> %7:gpr = LDD %stack.5.e, 0 :: (dereferenceable load (s64) from %ir.e)
Regs: W1=%3 W2=%4 W3=%5 W4=%6 W5=%7
In def of %7 use existing assignment to $r5
Freeing $r5: %7
<< $r5 = LDD %stack.5.e, 0 :: (dereferenceable load (s64) from %ir.e)

>> %6:gpr = LDD %stack.4.d, 0 :: (dereferenceable load (s64) from %ir.d)
Regs: W1=%3 W2=%4 W3=%5 W4=%6
In def of %6 use existing assignment to $r4
Freeing $r4: %6
<< $r4 = LDD %stack.4.d, 0 :: (dereferenceable load (s64) from %ir.d)

>> %5:gpr = LDD %stack.3.c, 0 :: (dereferenceable load (s64) from %ir.c)
Regs: W1=%3 W2=%4 W3=%5
In def of %5 use existing assignment to $r3
Freeing $r3: %5
<< $r3 = LDD %stack.3.c, 0 :: (dereferenceable load (s64) from %ir.c)

>> %4:gpr = LDD %stack.2.b, 0 :: (dereferenceable load (s64) from %ir.b)
Regs: W1=%3 W2=%4
In def of %4 use existing assignment to $r2
Freeing $r2: %4
<< $r2 = LDD %stack.2.b, 0 :: (dereferenceable load (s64) from %ir.b)

>> %3:gpr = LDD %stack.1.a, 0 :: (dereferenceable load (s64) from %ir.a)
Regs: W1=%3
In def of %3 use existing assignment to $r1
Freeing $r1: %3
<< $r1 = LDD %stack.1.a, 0 :: (dereferenceable load (s64) from %ir.a)

>> STD %1:gpr, %stack.7.g, 0 :: (store (s64) into %ir.g)
Regs:
Search register for %1 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %1 to $r1
<< STD killed $r1, %stack.7.g, 0 :: (store (s64) into %ir.g)

>> STD %2:gpr, %stack.6.f, 0 :: (store (s64) into %ir.f)
Regs: W1=%1
Search register for %2 in class GPR with hint $noreg
	Register: $r1 Cost: 100 BestCost: 4294967295
	Register: $r2 Cost: 0 BestCost: 100
Assigning %2 to $r2
<< STD killed $r2, %stack.6.f, 0 :: (store (s64) into %ir.f)

>> STD %1:gpr, %stack.5.e, 0 :: (store (s64) into %ir.e)
Regs: W1=%1 W2=%2
<< STD $r1, %stack.5.e, 0 :: (store (s64) into %ir.e)

>> STD %2:gpr, %stack.4.d, 0 :: (store (s64) into %ir.d)
Regs: W1=%1 W2=%2
<< STD $r2, %stack.4.d, 0 :: (store (s64) into %ir.d)

>> STD %1:gpr, %stack.3.c, 0 :: (store (s64) into %ir.c)
Regs: W1=%1 W2=%2
<< STD $r1, %stack.3.c, 0 :: (store (s64) into %ir.c)

>> STD %2:gpr, %stack.2.b, 0 :: (store (s64) into %ir.b)
Regs: W1=%1 W2=%2
<< STD $r2, %stack.2.b, 0 :: (store (s64) into %ir.b)

>> %2:gpr = MOV_ri 10
Regs: W1=%1 W2=%2
In def of %2 use existing assignment to $r2
Freeing $r2: %2
<< $r2 = MOV_ri 10

>> STD %1:gpr, %stack.1.a, 0 :: (store (s64) into %ir.a)
Regs: W1=%1
<< STD $r1, %stack.1.a, 0 :: (store (s64) into %ir.a)

>> %1:gpr = MOV_ri 9
Regs: W1=%1
In def of %1 use existing assignment to $r1
Freeing $r1: %1
<< $r1 = MOV_ri 9

>> STW killed %0:gpr, %stack.0.retval, 0 :: (store (s32) into %ir.retval)
Regs:
Search register for %0 in class GPR with hint $noreg
	Register: $r1 Cost: 0 BestCost: 4294967295
Assigning %0 to $r1
<< STW killed $r1, %stack.0.retval, 0 :: (store (s32) into %ir.retval)

>> %0:gpr = MOV_ri 0
Regs: W1=%0
In def of %0 use existing assignment to $r1
Freeing $r1: %0
<< $r1 = MOV_ri 0
Begin Regs:
Loading live registers at begin of block.
bb.0.entry:
  $r1 = MOV_ri 0
  STW killed $r1, %stack.0.retval, 0 :: (store (s32) into %ir.retval)
  $r1 = MOV_ri 9
  STD $r1, %stack.1.a, 0 :: (store (s64) into %ir.a)
  $r2 = MOV_ri 10
  STD $r2, %stack.2.b, 0 :: (store (s64) into %ir.b)
  STD $r1, %stack.3.c, 0 :: (store (s64) into %ir.c)
  STD $r2, %stack.4.d, 0 :: (store (s64) into %ir.d)
  STD $r1, %stack.5.e, 0 :: (store (s64) into %ir.e)
  STD killed $r2, %stack.6.f, 0 :: (store (s64) into %ir.f)
  STD killed $r1, %stack.7.g, 0 :: (store (s64) into %ir.g)
  $r1 = LDD %stack.1.a, 0 :: (dereferenceable load (s64) from %ir.a)
  $r2 = LDD %stack.2.b, 0 :: (dereferenceable load (s64) from %ir.b)
  $r3 = LDD %stack.3.c, 0 :: (dereferenceable load (s64) from %ir.c)
  $r4 = LDD %stack.4.d, 0 :: (dereferenceable load (s64) from %ir.d)
  $r5 = LDD %stack.5.e, 0 :: (dereferenceable load (s64) from %ir.e)
  ADJCALLSTACKDOWN 16, 0, implicit-def dead $r11, implicit $r11
  JAL @add, implicit-def $r0, implicit-def dead $r1, implicit-def dead $r2, implicit-def dead $r3, implicit-def dead $r4, implicit-def dead $r5, implicit $r11, implicit killed $r1, implicit killed $r2, implicit killed $r3, implicit killed $r4, implicit killed $r5
  ADJCALLSTACKUP 16, 0, implicit-def dead $r11, implicit $r11
  STW killed $r0, %stack.8.cc, 0 :: (store (s32) into %ir.cc)
  $r0 = LDW %stack.8.cc, 0 :: (dereferenceable load (s32) from %ir.cc)
  RET implicit killed $r0
Skipping pass 'Fixup Statepoint Caller Saved' on function main
alloc FI(0) at SP[-4]
alloc FI(1) at SP[-16]
alloc FI(2) at SP[-24]
alloc FI(3) at SP[-32]
alloc FI(4) at SP[-40]
alloc FI(5) at SP[-48]
alloc FI(6) at SP[-56]
alloc FI(7) at SP[-64]
alloc FI(8) at SP[-68]
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: main
Skipping pass 'BPF PreEmit Checking' on function main
********** COMPUTING STACKMAP LIVENESS: main **********

Debug Range Extension
